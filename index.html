<!DOCTYPE html>
<html lang="en">
<head>
    <title>Oxford Common File Layout Specification</title>
    <meta charset="utf-8">
    <meta name="description" content="Oxford Common File Layout Specification">
    <script src="./respec-w3c-common.js"
            async class="remove"></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            shortName: "ocfl-spec",
            includePermalinks: true,
            editors: [
                {
                    name: "Andrew Hankinson",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Neil Jefferies",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Rosalyn Metz",
                    company: "Emory University",
                    companyURL: "https://web.library.emory.edu/"
                },
                {
                    name: "Julian Morley",
                    company: "Stanford University",
                    companyURL: "https://library.stanford.edu/"
                },
                {
                    name: "Simeon Warner",
                    url: "https://orcid.org/0000-0002-7970-7855",
                    company: "Cornell University",
                    companyURL: "https://www.library.cornell.edu/"
                },
                {
                    name: "Andrew Woods",
                    company: "DuraSpace",
                    companyURL: "http://duraspace.org/"
                }
            ],
            edDraftURI: "https://ocfl.io",
            wg: "Oxford Common File Layout Editors",
            wgURI: "https://ocfl.io",
            wgPublicList: "",
            otherLinks: [{
                key: "Previous version",
                data: [
                    {
                        value: "N/A"
                    }
                ]
            }, {
                key: "Repository",
                data: [
                    {
                        value: "Github",
                        href: "https://github.com/ocfl/spec"
                    },
                    {
                        value: "Issues",
                        href: "https://github.com/ocfl/spec/issues"
                    },
                    {
                        value: "Commits",
                        href: "https://github.com/ocfl/spec/commits"
                    },
                    {
                        value: "Use Cases",
                        href: "https://github.com/ocfl/Use-Cases"
                    }
                ]
            }],
            maxTocLevel: 3,
            logos: [{
                src: "https://avatars0.githubusercontent.com/u/35607965",
                alt: "OCFL Logo",
                width: 307,
                height: 307
            }],
            overrideCopyright: '<p class="copyright">This document is licensed under a ' +
                '<a class="subfoot" href="https://creativecommons.org/licenses/by/4.0/" rel="license">' +
                'Creative Commons Attribution 4.0 License</a>.</p>',
            localBiblio: {
                "Moab": {
                    title: "The Moab Design for Digital Object Versioning",
                    href: "https://journal.code4lib.org/articles/8482",
                    authors: [
                        "Richard Anderson"
                    ],
                    date: "15 July 2013"
                },
                "NAMASTE": {
                    title: "Directory Description with Namaste Tags",
                    href: "https://confluence.ucop.edu/download/attachments/14254149/NamasteSpec.pdf",
                    authors: [
                        "J. Kunze"
                    ],
                    date: "9 November 2009"
                },
                "JSON-LD-1.1": {
                   title: "JSON-LD 1.1: A JSON-based Serialization for Linked Data",
                   href: "https://json-ld.org/spec/latest/json-ld/",
                   authors: [
                        "Manu Sporny", "Dave Longley", "Gregg Kellogg", "Markus Lanthaler", "Niklas Lindström"
                   ],
                   date: "7 June 2018"
                },
                "Stop-Using-SHA-256": {
                  title: "Stop Using SHA-256",
                  href: "https://medium.com/@davidtstrauss/stop-using-sha-256-6adbb55c608",
                  authors: [
                    "David Timothy Strauss"
                  ],
                  date: "6 October 2017"
                }
            }
        };
    </script>
    <style>
        em.rfc2119 {
            text-transform: lowercase;
            font-variant: small-caps;
            font-style: normal;
            color: #900;
        }
    </style>
</head>
<body>
<section id="abstract" class="informative">
    <h2>Introduction</h2>
    <p>
        This Oxford Common File Layout (OCFL) specification describes an application-independent approach to the storage
        of digital information in a structured, transparent, and predictable manner. It is designed to promote long-term
        object management best practices within digital repositories.
    </p>
    <p>
        This specification covers two principle areas:
    </p>
    <ol>
        <li>Structure. A normative specification of the nature of an OCFL Object (the "object-at-rest");</li>
        <li>Client Behaviors. A set of recommendations for how OCFL Objects should be acted upon (the
            "object-in-motion")
        </li>
    </ol>
    <section id="need">
        <h2>Need</h2>
        <p>
           The OCFL initiative arose from a need to have well-defined application-independent file management within
           digital repositories.
        </p>
        <p>
           A general observation is that the contents of a digital repository -- that is, the digital files and metadata
           that an institution might wish to manage -- are largely stable. Once content has been accessioned, it is
           unlikely to change significantly over its lifetime. This is in contrast to the software applications that
           manage these contents, which are ephemeral, requiring constant updating and replacement. Thus, transitions
           between application-specific methods of file management to support software upgrades and replacement cycles
           can be seen as unnecessary and risky change, changing the long-term stable objects to support the short-term,
           ephemeral software.
        </p>
        <p>
           By providing a specification for the file and directory layout on disk, the OCFL is an attempt at reducing,
           or even eliminating, the need for these transitions. As an application-independent specification, conforming
           applications will natively "understand" the underlying file structure without needing to first transition
           these contents to their own format.
         </p>
    </section>
</section>

<section id="sotd">
</section>

<section id="conformance">
</section>

<section id="terminology">
    <h2>Terminology</h2>
    <dl>
        <dt><dfn>Additions</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Deleting</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Digest</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Existing File Path</dfn>:</dt>
        <dd>The file path as it appears on disk including the directories and the
          filename.</dd>
        <dt><dfn>Existing State</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Inventory Digest</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Inventory File</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Logical File Path</dfn>:</dt>
        <dd>The file path relative to the version including the directories and the
          filename.</dd>
        <dt><dfn>Logical State</dfn>:</dt>
        <dd>The logical state of the object is a grouping of logical file paths
          reflecting the state of the content for a given version.</dd>
        <dt><dfn>Logs Directory</dfn>:</dt>
        <dd>The Logs Directory appears in the top level of the OCFL Object.  The purpose of the
          Logs Directory is to provide implementers with a place for storing local information
          about actions performed on the content that may not necessarily be part of the content
          itself.</dd>
        <dt><dfn>OCFL Object</dfn>:</dt>
        <dd></dd>
        <dt><dfn>OCFL Object Root</dfn>:<dt>
        <dd></dd>
        <dt><dfn>OCFL Storage Root</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Purging</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Renaming</dfn>:</dt>
        <dd></dd>
        <dt><dfn>Version</dfn>:<dt>
        <dd></dd>
    </dl>
</section>

<section id="object-spec">
    <h2>OCFL Object</h2>
    <p>
        An OCFL Object is a group of one or more content files and administrative information, that are together
        identified by a URI. The object may contain a sequence of versions of the files that represent the evolution
        of the object's contents.
    </p>
    <p>
        A file is defined as a content bitstream that can be stored and transmitted. Directories (also called "folders")
        allow for the organization of files into tree-like hierarchies. The content of an OCFL Object is the files and
        the directories they are organized in that are stored <i>within</i> the hierarchy layout described in this
        specification.
    </p>
    <p>
        The administrative information is specific to OCFL Objects. Implementers of OCFL are strongly encouraged to
        store their own metadata serializations as files in an OCFL Object, but, in the context of the OCFL
        Specification these are considered to be part of the contents of an OCFL Object.
    </p>
    <p>
        An OCFL Object is therefore:
    </p>
    <ol>
        <li>A conceptual gathering of all files (data and metadata), the directories they are organized in, and their
            changes over time which together form the digital representation of an entity that need to be managed, in
            preservation terms, as a single coherent whole (i.e., content); and</li>
        <li>A file and directory layout and administrative information on a storage medium that provides a defined
            structure for the storage of this content, and through which these files and their changes may be understood
            (i.e., structure).</li>
    </ol>
    <p>
        A key goal of OCFL is the rebuildability of a repository from an OCFL storage root without additional
        information resources. Consequently, a key implementation consideration should be to ensure that OCFL Objects
        contain all the data and metadata required to achieve this. With reference to th OAIS model, this would include
        all the descriptive, administrative, structural, representation and preservation metadata relevant to the
        object.
    </p>

    <section id="basic-structure">
        <h2>Basic Structure</h2>
        <p>
            The basic OCFL Object structure has a minimal set of files and directories necessary to support data
            storage and object validation. The minimum required is shown in the following figure:
        </p>
        <pre>
[object_root]
    ├── 0=ocfl_object_1.0
    ├── inventory.jsonld
    ├── inventory.jsonld.sha512
    └── v1
        ├── inventory.jsonld
        └── inventory.jsonld.sha512
        </pre>
    </section>

    <section id="object-conformance-declaration">
        <h2>Object Conformance Declaration</h2>
        <p>
            The version declaration MUST be formatted according to the [[!NAMASTE]] specification. It MUST be an empty
            file in the base directory of the object giving the OCFL Object version in the filename. The filename MUST
            be constructed with a leading zero-equals (<code>0=</code>) string, the string <code>ocfl_object_</code>,
            followed by the OCFL specification version number. For example <code>0=ocfl_object_1.0</code> for version
            1.0 of this specification.
        </p>
    </section>

    <section id="version-directories">
        <h2>Version Directories</h2>
        <p>
            OCFL Object content is stored as a sequence of one or more versions. Each object version is stored in a
            version directory under the object root. The sequence of version numbers is the sequence of positive
            integers: 1, 2, 3, etc., and the version directory name is constructed by adding the prefix <code>v</code>.
        </p>
        <p>
            Implementations SHOULD use version directory names constructed without zero-padding the
            version number, ie. <code>v1</code>, <code>v2</code>, <code>v3</code>, etc..
        </p>
        <p>
            For compatibility with existing filesystem conventions, implementations MAY use zero-padded version numbers,
            with the following restriction: If zero-padded version numbers are used then they MUST start with a zero.
            For example, in an implementation that uses five digits the version directory names <code>v00001</code> to
            <code>v09999</code> are allowed, <code>v10000</code> is not allowed.
        </p>
        <p>
            The first version of an object defines the naming convention for all versions of the object. All versions of
            an object MUST use the same naming convention: either a non-padded version number, or a zero-padded version
            number of consistent length. Operations that add a new version to an object MUST follow the directory naming
            convention established by earlier versions. In all cases, references to files inside version directories
            from inventory files MUST use the actual version directory names.
        </p>
        <p>
            Empty directories within a version directory are not permitted. Otherwise empty directories MAY be
            maintained by creating a <code>.keep</code> file within that directory.
        </p>
    </section>

    <section id="digests">
        <h2>Digests</h2>
        <p>
            Digests play two roles in an OCFL Object. The first is that digests allow for content-addressable
            storage; that is, for a file to be addressed by the digest of its contents, rather than its filename.
            The second is that digests provide for fixity checks to determine whether a file has become corrupt
            through hardware degradation or malicious actors.
        </p>
        <p>
            OCFL Objects SHOULD use <code>sha512</code> by default. The choice of <code>sha512</code> recognizes
            that it has no known collision vulnerabilities and is less computationally intensive to compute than
            <code>sha256</code>, [[Stop-Using-SHA-256]].
        </p>
        <p>
            For content addressability OCFL Objects MUST use either <code>sha256</code> or <code>sha512</code>, to
            reduce the likelihood of known digest collision vulnerabilities.
        </p>
        <p>
            However, for legacy content migration and consistency implementers may choose from the following
            list of digest algorithms for storing fixity values:
        </p>
        <table class="simple" id="digest-algorithms">
            <thead>
            <tr>
                <th>Digest Algorithm</th>
                <th>Note</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><code>md5</code></td>
                <td>Insecure. Use only for legacy content. MD5 algorithm and encoding defined by
                    [[!RFC1321]].</td>
            </tr>
            <tr>
                <td><code>sha1</code></td>
                <td>Insecure. Use only for legacy content. SHA-1 algorithm defined by [[!FIPS-180-4]] and MUST
                    be encoded using base64 encoding [[!RFC4648]].</td>
            </tr>
            <tr>
                <td><code>sha256</code></td>
                <td>Non-truncated only; note performance implications. SHA-256 algorithm defined by
                    [[!FIPS-180-4]] and MUST be encoded using base64 encoding [[!RFC4648]].</td>
            </tr>
            <tr>
                <td><code>sha512</code></td>
                <td>Default choice. Non-truncated forms only. SHA-512 algorithm defined by [[!FIPS-180-4]] and
                    MUST be encoded using base64 encoding [[!RFC4648]].</td>
            </tr>
            </tbody>
        </table>
        <p>
            An OCFL Inventory MAY contain a fixity section that can store one or more blocks containing fixity values
            using multiple digest algorithms. See the <a href="#fixity">section on fixity</a> below for further details.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: Implementers may also store copies of their file digests in a system external to
                their OCFL Object stores at the point of ingest, to further safeguard against the possibility of
                malicious manipulation of file contents and digests.
            </p>
        </blockquote>
    </section>

    <section id="inventory">
        <h2>Inventory</h2>
        <p>
            An OCFL Object Inventory MUST follow the [[!JSON]] structure described in this section and MUST be named
            <code>inventory.jsonld</code>. Furthermore, inventory files MUST conform to [[!JSON-LD-1.1]], MUST include
            the JSON-LD <code>@context</code> value
            <a href="context.jsonld"><code>https://ocfl.io/context.jsonld</code></a>.
        </p>
        <blockquote class="informative">
            Non-normative note: The use of JSON-LD for inventory files means that they can be generated from and
            interpreted as RDF, and provides some self-documentation. The fixed JSON structure means that they can
            also be generated and read without requiring RDF and JSON-LD support.
        </blockquote>

        <section id="inventory-structure">
            <h2>Basic Structure</h2>
        </section>

        <section id="manifest">
            <h2>Manifest</h2>
        </section>

        <section id="versions">
            <h2>Versions</h2>
            <p>
                An OCFL Object Inventory MUST include a block for storing versions. This block MUST have the
                key of <code>versions</code> within the inventory, and it MUST be an array.
            </p>
            <p>
                The <code>versions</code> array MUST be a list of one or more JSON objects of type <code>Version</code>.
            </p>
            <section id="version">
                <h2>Version</h2>
                <p>
                    A JSON object of type <code>Version</code> which MUST include the following keys:
                </p>
                <dl>
                    <dt>
                        <code>type</code>
                    </dt>
                    <dd>
                        The value of this key MUST be <code>Version</code>.
                    </dd>
                    <dt>
                        <code>version</code>
                    </dt>
                    <dd>
                        The value of this key MUST correspond to the name of a version directory within the <a>OCFL
                        Object</a>.
                    </dd>
                    <dt>
                        <code>created</code>
                    </dt>
                    <dd>
                        The value of this key MUST be expressed in [[!ISO8601]], and SHOULD include a timezone value
                        or UTC. It SHOULD also be granular to the second level.
                    </dd>
                    <dt>
                        <code>message</code>
                    </dt>
                    <dd>
                        The value of this key is freeform text, used to record the rationale for creating this version.
                    </dd>
                    <dt>
                        <code>user</code>
                    </dt>
                    <dd>
                        The value of this key is a JSON object, containing a readable user name key, <code>name</code>
                        and an address key, <code>address</code>. The format of the address key MAY be either an
                        e-mail address or a URI reference to a personal identifier, e.g., an ORCID iD.
                    </dd>
                    <dt>
                        <code>state</code>
                    </dt>
                    <dd>
                        <p>
                            The value of this key is a JSON object, containing a list of keys and values corresponding
                            to the <a>logical state</a> of the object at that version. The keys of this JSON object
                            are <a>logical file path</a> names which correspond to the state of the
                            OCFL Object at that version. The values of each key is a string containing a digest which
                            MUST correspond to an entry in the <a href="#manifest">manifest of the inventory</a>.
                        </p>
                        <blockquote class="informative">
                            <p>
                                Non-normative note: The <a>logical state</a> of the object uses content-addressable
                                techniques to map <a>logical file paths</a> to their bitstreams, as expressed in
                                the manifest section of the inventory.
                            </p>
                            <p>
                                Notably, the version state can be used to provide de-duplication of content within
                                the OCFL Object, by mapping multiple <a>logical file paths</a> to the same content 
                                digestin the manifest. Implementers may choose to use this functionality on a 
                                case-by-case basis. For example, they may choose to implement renaming (that is, 
                                changes in file <i>name</i>, but not file <i>content</i>) by pointing a new logical 
                                file path to the digest for content that was added in a previous version. Implementers
                                may also, however, choose to accession a new file with a new name and same content as 
                                a new version.
                            </p>
                        </blockquote>
                        <p>An example state object is shown below.</p>
                        <pre>
                            TBD
                        </pre>
                    </dd>
                </dl>
            </section>
        </section>

        <section id="fixity">
            <h2>Fixity</h2>
            <p>
                An OCFL Object inventory MAY include a block for storing fixity checks. This block MUST have the
                key of <code>fixity</code> within the inventory.
            </p>
            <p>
                The structure of the <code>fixity</code> section MUST contain a key corresponding to an
                <a href="#digest-algorithms">approved digest algorithm</a>. The value of this key MUST follow the
                structure of the <a href="#manifest"><code>manifest</code></a> section; that is, a key corresponding
                to the digest value, and an array of file paths that match that digest.
            </p>
            <p>
                An example fixity section is shown below.
            </p>
            <pre>
TBD
            </pre>
        </section>
    </section>

    <section id="inventory-digest">
        <h2>Inventory Digest</h2>
        <p>
            Every occurrence of an inventory file MUST have an accompanying sidecar file stating its digest. This
            sidecar file must be of the form <code>inventory.jsonld.ALGORITHM</code>, where <code>ALGORITHM</code> is
            the chosen digest algorithm for the object. An example might be <code>inventory.jsonld.sha512</code>.
        </p>
        <p>
            The digest sidecar file MUST contain the digest of the inventory file. This MUST follow the format
            <code>DIGEST inventory.jsonld</code>; that is, the digest of the inventory file, a single space, and the
            name of the inventory file.
        </p>
        <p>
            The digest of the inventory MUST be computed only after all changes to the inventory have been made, so this
            sidecar file SHOULD be created as the last step in the versioning process.
        </p>
    </section>

    <section id="version-inventory">
        <h2>Version Inventory and Inventory Digest</h2>
        <p>
            Every version directory SHOULD include an inventory file that is an <a href="#inventory">Inventory</a>
            of all content for versions up to and including that particular version. Every inventory file MUST have
            a corresponding <a href="#inventory-digest">Inventory Digest</a>.
        </p>
        <blockquote class="informative">
            Non-normative note: Storing an inventory for every version provides redundancy for this critical
            information in a way that is compatible with storage strategies that have immutable version directories.
        </blockquote>
    </section>

    <section id="logs-directory">
        <h2>Logs Directory</h2>
        <p>
            The base directory of the object MAY contain a logs directory, which MAY be empty. Implementers SHOULD use
            this for storing files that contain a record of actions taken on the object. Since these logs may be subject
            to local standards requirements, the format of these logs is considered out-of-scope for the OCFL Object.
            Clients operating on the object MAY log actions here that are not otherwise captured.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: The purpose of the logs directory is to provide implementers with a location for
                storing local information about actions to the OCFL Object's content that is not part of the content
                itself.
            </p>
            <p>
                As an example, implementers may have different local requirements to store audit information for their
                content. Some may wish to store a log entry indicating that an audit was conducted, and nothing was
                wrong, while others may wish to only store a log entry if an intervention was required.
            </p>
        </blockquote>

    </section>
</section>

<section id="storage-root">
    <h2>OCFL Storage Root</h2>

    <section id="root-conformance-declaration">
        <h2>Root Conformance Declaration</h2>
            The OCFL version declaration MUST be formatted according to the [[!NAMASTE]] specification. It MUST be an
            empty file in the base directory of the <a>OCFL Storage Root</a> giving the OCFL version in the filename.
            The filename MUST be constructed with a leading zero-equals (<code>0=</code>) string, the string
            <code>ocfl_</code>, followed by the OCFL specification version number. For example <code>0=ocfl_1.0</code>
            for version 1.0 of this specification.
    </section>

    <section id="root-structure">
        <h2>Root Structure</h2>
    </section>

    <section id="root-extensions">
        <h2>Extensions</h2>
    </section>
</section>

<section id="examples" class="informative">
    <h2>Examples</h2>

    <section id="example-minimal-object">
        <h2>Minimal Object</h2>
    </section>

    <section id="example-bagit-in-ocfl">
        <h2>BagIt in an OCFL Object</h2>
    </section>

    <section id="example-moab-in-ocfl">
        <h2>Moab in an OCFL Object</h2>
        <p>
            [[Moab]] is an archive information package format developed and used by Stanford University.
            Many of the ideas in Moab have been refined by OLFL, and OCFL is designed to
            give institutions currently using Moab an easy path to adoption.
        </p>
        <p>
            Converting content preserved in a Moab object in a way that does not compromise existing Moab
            access patterns whilst allowing for the eventual use of OCFL-native workflows requires a Moab to
            OCFL conversion tool. This tool uses the Moab-versioning gem to extract deltas and digests
            of the Moab data directory for each Moab version and translate those into version state blocks
            in an OCFL inventory file, which would be placed in the root directory of the Moab object.
            All extant files in the Moab version directories are tracked in the manifest block. The contents
            of the Moab manifests directory are not tracked in the version state blocks; they are effectively
            deleted from the OCFL object without compromising legacy access patterns.
        </p>
        <p>
            During the transitionary period the OCFL inventory file exists only in the root of the Moab object.
            Once OCFL-native object creation workflows have been completed, future versions of that object will
            be fully OCFL compliant - new versions will no longer have a manifests directory and will contain an
            OCFL inventory file. At this stage OCFL tools will be able to access all versions of the content
            originally preserved by Moab.
        </p>
    </section>
</section>

</body>
</html>
