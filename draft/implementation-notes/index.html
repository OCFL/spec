<!DOCTYPE html>
<html lang="en">
<head>
    <title>Implementation Notes, Oxford Common File Layout Specification</title>
    <meta charset="utf-8">
    <meta name="description" content="Client Behaviours, Oxford Common File Layout Specification">
    <script src="../../respec-w3c-common.js"
            async class="remove"></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            shortName: "ocfl-spec",
            includePermalinks: true,
            editors: [
                {
                    name: "Andrew Hankinson",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Neil Jefferies",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Rosalyn Metz",
                    company: "Emory University",
                    companyURL: "https://web.library.emory.edu/"
                },
                {
                    name: "Julian Morley",
                    company: "Stanford University",
                    companyURL: "https://library.stanford.edu/"
                },
                {
                    name: "Simeon Warner",
                    url: "https://orcid.org/0000-0002-7970-7855",
                    company: "Cornell University",
                    companyURL: "https://www.library.cornell.edu/"
                },
                {
                    name: "Andrew Woods",
                    company: "DuraSpace",
                    companyURL: "http://duraspace.org/"
                }
            ],
            edDraftURI: "https://ocfl.io/draft/implementation-notes/",
            wg: "Oxford Common File Layout Editors",
            wgURI: "https://ocfl.io",
            wgPublicList: "",
            otherLinks: [{
                key: "Previous version",
                data: [
                    {
                        value: "N/A"
                    }
                ]
            }, {
                key: "Repository",
                data: [
                    {
                        value: "Github",
                        href: "https://github.com/ocfl/spec"
                    },
                    {
                        value: "Issues",
                        href: "https://github.com/ocfl/spec/issues"
                    },
                    {
                        value: "Commits",
                        href: "https://github.com/ocfl/spec/commits"
                    },
                    {
                        value: "Use Cases",
                        href: "https://github.com/ocfl/Use-Cases"
                    }
                ]
            }],
            maxTocLevel: 3,
            logos: [{
                src: "https://avatars0.githubusercontent.com/u/35607965",
                alt: "OCFL Logo",
                width: 307,
                height: 307
            }],
            overrideCopyright: '<p class="copyright">This document is licensed under a ' +
                '<a class="subfoot" href="https://creativecommons.org/licenses/by/4.0/" rel="license">' +
                'Creative Commons Attribution 4.0 License</a>.</p>',
            localBiblio: {
                "NAMASTE": {
                    title: "Directory Description with Namaste Tags",
                    href: "https://confluence.ucop.edu/download/attachments/14254149/NamasteSpec.pdf",
                    authors: [
                        "J. Kunze"
                    ],
                    date: "9 November 2009"
                },
                "OAIS": {
                    title: " Reference Model for an Open Archival Information System (OAIS), Issue 2",
                    href: "https://public.ccsds.org/pubs/650x0m2.pdf",
                    date: "June 2012"
                },
                "JSON-LD-1.1": {
                    title: "JSON-LD 1.1: A JSON-based Serialization for Linked Data",
                    href: "https://json-ld.org/spec/latest/json-ld/",
                    authors: [
                        "Manu Sporny", "Dave Longley", "Gregg Kellogg", "Markus Lanthaler", "Niklas Lindstr√∂m"
                    ],
                    date: "7 June 2018"
                    
                },
                "OCFL-Spec": {
                    title: "OCFL Specification",
                    href: "../spec"
                }
            }
        };
    </script>
    <style>
        em.rfc2119 {
            text-transform: lowercase;
            font-variant: small-caps;
            font-style: normal;
            color: #900;
        }
    </style>
</head>
<body>
    <section id="abstract" class="informative">
        <h2>Introduction</h2>
        <p>
            This document provides guidance to OCFL implementers for how clients should behave when operating on
            OCFL Objects.
        </p>
    </section>

    <section>
        <h2>Rebuildability</h2>
        <p>
            A key goal of OCFL is the rebuildability of a repository from an OCFL storage root without 
            additional information resources. Consequently, a key implementation consideration should be 
            to ensure that OCFL objects contain all the data and metadata required to achieve this. With 
            reference to the [[OAIS]] model, this would include all the descriptive, administrative, structural,
            representation and preservation metadata relevant to the object.
        </p>
        <p>
            Additionally, as an aid to those who may need to recover OCFL objects in the future, it is 
            recommended that a copy of the [[OCFL-Spec]] is stored in the top level of the OCFL storage
            root. OCFL ignores files other than the conformance declaration at the top level so it is a 
            good location to store documentation that may be useful for recovery.
        </p>
        <p>
            A more complete approach would be to create a specific OCFL object that contains this 
            documentation and to have a pointer to its location in the storage root. This documentation
            object would then be subject OCFL validation and any other digital preservation processes
            that might be implemented without requiring special handling.   
        </p>
    </section>
    
    <section>
        <h2>Filesystem metadata</h2>
        <p>
            Filesystem metadata (e.g. permissions, access and creation times) are not considered portable 
            between filesystems or preservable through file transfer operations. Nor can these attributes be 
            validated in terms of fixity in a consistent manner. As such, OCFL neither explicitly supports nor 
            expects that these quanties remain consistent. If retaining this metadata is important then files 
            should either be encapsulated in a filesystem image format that preserves this information, or the 
            required metadata extracted and stored explicitly in an additional file.
        </p>
    </section>
    
    <section>
        <h2>Empty Directories</h2>
        <p>
            OCFL preserves files and their content, with directories serving as a useful organisational 
            convention. An empty directory consists only of filesystem metadata and therefore, as noted above,
            is not preserved in OCFL. If the preservation of empty directories is considered essential then
            the suggested route is to insert zero length files named <code>.keep</code> into the directories 
            which will thus be preserved as part of the files' path.
        </p>
        <p>
            Note that <code>.keep</code> files are not considered special by OCFL in any way and are treated
            exactly the same way as other files. As such, a non-zero length <code>.keep</code> file is not 
            considered invalid.
        </p>
    </section>
    
    <section>
        <h2>Data and Metadata</h2>
        <p>
            OCFL object versions are composed of series of files/bitstreams but OCFL does not make any 
            distinction between different types of files other than those reserved for OCFL functionality: 
            the top level [[NAMASTE]] conformance declaration file, inventory files and their corresponding 
            digest files. It is possible, for example, to create separate data and metadata directories within
            each version to help organise material but all files are treated equally for the purpose of OCFL
            validation and management.
        </p>
    </section>
    
    <section>
        <h2>Storage</h2>
        <p>
            OCFL separates the stored file paths from the logical location of these files' content in OCFL object
            versions. This is a key feature that allows previous versions of objects to remain immutable but
            permitting deduplication, forward delta differencing, and easy file renaming. Consequently, OCFL 
            only requires that files added to any version of an OCFL object must be stored somewhere within the 
            relevant version directory, with a corresponding entry in the <code>manifest</code> block. An entry 
            in the <code>state</code> block determines the path and name of the file within that version by 
            referencing the relevant <code>manifest</code> entry, not the actual path on storage.
        </p>
        <p>
            The most transparent approach is to have the path used to store the file on disk the same as the path
            of the file within the object when accessioned. This is readily understandable in terms of visual 
            inspection of the physical filesystem.
        </p>
        <p>
            However, this is not always possible. For example, complex objects with deep file hierarchies may 
            encounter issues if they come a from fileystem that allows longer paths than are supported by the 
            target OCFL system. In this case, the decoupling between physical and logical file paths in OCFL 
            allows the use of truncated paths for storage while the full paths can be preserved in 
            <code>state</code> block entries which are not length constrained.
        </p>
        <p>
            Another use case is importing content from other repository systems which renames file on ingest 
            and stores them in a flat hierarchy. These can be imported, as is, and the original paths and file
            names recorded through suitable <code>state</code> block entries rather than reconstructing a physical
            file layout. Of course, OCFL supports ongoing use of such a methodology, if desired.
        </p>
    </section>

    <section>
        <h2>Storage Root Hierarchy</h2>
        <p>
            Strictly speaking, OCFL only requires that OCFL objects, identified by the presence 
        </p>
    </section>
    
    <section>
        <h2>Basic File Operations</h2>
        <p>
            OCFL and its inventory structure are designed to support and capture the following file operations
            that create OCFL versions, regardless of whether optional features, such as deduplication, are used.
            <ul>
                <li>
                    Inheritance: By default a new version of an OCFL object inherits all the filenames and file
                    content from the previous version. This serves as the basis against which changes are applied
                    to create a new version. A newly created OCFL object, obviously, inherits no content and is 
                    populated by file additions.
                </li>
                <li>
                    Addition: Adds a new file path and corresponding content to an OCFL object. The path cannot 
                    exist in the previous version of the object, and the content cannot have existed in any
                    earlier versions of the object.
                </li>
                <li>
                    Updating: Changes the content pointed to by an exsting file path. The path must exist in 
                    the previous version of the OCFL object, and the content cannot have existed in any earlier 
                    versions of the object.
                </li>
                <li>
                    Renaming: Changes the file path of existing content. The path cannot exist in the previous
                    version of the OCFL object, and the content cannot have existed in any earlier versions of 
                    the bject.
                </li>
                <li>
                    Deletion: Removes a file path and corresponding content from the current version of an OCFL
                    object. The path and content remain available in earlier versions of the object.
                </li>
                <li>
                    Reinstatement: Makes content from a version earlier than the previous version available in
                    the current version. The content must exist in an earlier version, and not the previous 
                    version. The file path may exist in the previous version, effectively updating the file path
                    with older content, or it may not, effectively adding the older content as a new file. 
                </li>
                <li>
                    Purging: Purging, as distinct from deletion, covers the complete removal of a file path and
                    corresponding content from all versions of an OCFL object. This is a special case that is 
                    not supported as part of regular OCFL versioning operations. An approach to implementing this
                    is covered in a later section. 
                </li>
            </ul>
        </p>
    </section>
    
    <section>
        <h2>Version Immutability</h2>
        <p>
            Previous versions of an object should be considered immutable since the composition of later 
            versions of an object may be dependent on them. In addition, the assumption of immutability ensures
            that copies of different versions of an object remain consistent with each other, avoiding issues with
            identifying canonicity and reconcilitation.
        </p>
        <p>
            One key consequence of this immutabilty is that <code>manifest</code> entries should never be deleted. New 
            entries may be created, and, if not deduplicating file content, additional references to copies of
            stored content may be added.
        </p>
    </section>
    
    <section>
        <h2>Deduplication</h2>
        <p>
            OCFL supports optional deduplication if a client ensures that all digests in the <code>manifest</code> 
            block refer to a single file path on disk. This entry is created the first time particular file content
            is stored in an object. Subsequent references to that file content should then occur in the 
            <code>state</code> block only. This can be determined by computing the digests of incoming files and 
            determining if they already exist in the <code>manifest</code> block. 
        </p>
        <p>
            If deduplication is carried out within an object then, for consistency, it is expected that 
            Forward Delta differencing will also be used between object versions so subsequent references
            to duplicated content should also refer back to the original <code>manifest</code> entry rather 
            than updating it to include additional references.
        </p>
    </section>
    
    <section>
        <h2>Forward Delta</h2>
        <p>
            Forward delta differencing is a key, though optional, feature of OCFL that means that parts of an
            OCFL object version that are unchanged from a previous version are not stored again. This has the 
            potential to signficantly improve storage efficiency when objects have multiple versions, whether
            through ongoing curatorial action or the accessioning of updated material.
        </p>
        <p>
            When a new version of an OCFL Object is created from an earlier version and a client wishes to 
            implement forward delta differencing, then the possible file operations are handled in the following 
            manner (with reference to the <code>state</code> and <code>manifest</code> blocks of the OCFL 
            object's inventory file):
        <ul>
            <li>
                Inheritance: Files inherited from the previous version unchanged are referenced in the 
                <code>state</code> block of the new version. These entries will be identical to the corresponding 
                entries in the previous version's <code>state</code> block. No changes to the <code>manifest</code> 
                block are required. When a new OCFL version of an OCFL object is created, the starting point against 
                which changes are made should be to copy the entire <code>state</code> block of the previous version, 
                thus inheriting all the files and content from the previous version.  
            </li>
            <li>
                Addition: Newly added files appear as new entries in the <code>state</code> block of the new version. 
                The file should be stored and an entry for the new content must be made in the <code>manifest</code>
                block of the object's inventory. The new digest from the <code>manifest</code> block can then be used
                to create the new <code>state</code> block entry. If the file content, as determined by its digest, 
                corresponds to an existing <code>manifest</code> entry then, technically, this is a reinstatement 
                operation rather than addition and should be flagged to prevent the operation being recorded incorrectly
                in preservation logs.  
            </li>
            <li>
                Updating: Files updated from the previous version appear as changed entries in the <code>state</code> 
                block of the new version - with new digests associated with existing file paths. The updated file should 
                be stored and a new entry for the updated content must be made in the <code>manifest</code> block of the 
                object's inventory. The new digest can then be used to replace the digest for the old content in
                the relevant <code>state</code> block entry. If the file content, as determined by its digest, corresponds
                to an existing <code>manifest</code> entry then, technically, this is a reinstatement operation rather 
                than updating and should be flagged to prevent the operation being recorded incorrectly in preservation
                logs. 
            </li>
            <li>
                Renaming: Files renamed from the previous version appear as changed entries in the <code>state</code>
                block of the new version - with existing digests associated with new file paths. No changes to the 
                <code>manifest</code> block are required.
            </li>
            <li>
                Deletion: Files deleted from the previous version are simply removed from the <code>state</code>
                block of the new version.
            </li>
            <li>
                Reinstatement: Since reinstated content already exists in earlier versions of the OCFL object,
                no changes to the <code>manifest</code> block are required. Reinstated entries in the <code>state</code>
                block should replace any entries with the same path inherited from the previous version. If the file 
                paths are unchanged then these entries will be identical to the corresponding entries in the earlier 
                version's <code>state</code> block. 
            </li>
        </ul>
        </p>
    </section>

    <section>
        <h2>Fixity</h2>
        <p>
            The digests in the inventory are used by OCFL for content addressability rather than fixity but they
            are suitable for use as part of a fixity regime, and the <code>manifest</code> block usefully identifies
            all the files in an object. Additional fixity entries may be made in the <code>fixity</code> block which 
            permits a broader range of algorithms but has the same layout as a <code>manifest</code> block. OCFL will
            consider the <code>fixity</code> block valid provided that the files referenced in the block exist but 
            OCFL cannot, reasonably, validate the hashes themselves. The <code>fixity</code> block does not have to
            include all the files in an object to permit legacy fixity to be imported without requiring continued 
            use of obsolete digest algorithms.
        </p>
    </section>

    <section> 
        <h2>File Purging</h2>
        <p>
            Sometimes a file needs to be deleted from all versons of an object, perhaps for legal reasons. Doing
            this to an OCFL object breaks the previous version immutability assumption and is thus not supported 
            directly. The correct way to do this is to create a new object the excludes the offending file with
            a revised version history taking this into account. The original object can then be deleted in its 
            entirety. Creating the new object first is good practice to avoid any risk of data loss. The new 
            object will be unlikely to have the same identifier as the original object so the deleted object can
            be replaced by a stub object that directs users and software to the new version.
        </p>
    </section>

    <section>
        <h2>Log Information</h2>
        <p>
            There may be the need to record some actions on OCFL objects that do not result in changes to the
            object's logical state. For example, copying the object to new storage or validating fixity and finding 
            nothing amiss. The <code>log</code> directory is the location in an OCFL object where such events
            can be recorded. OCFL does not make any assumptions about the contents of this directory so, if it
            exists, then its contents will not be subject any validation processes.
        </p>
    </section>

    <section>
        <h2>Version Numbering</h2>
        <p>
            Version numbering should start with 1 and be positive sequential integers. Names start with a lower
            case <code>v</code>. The numbers may be zero padded to the left to give fixed length, but, if used, 
            zero padded numbers must always retain at least one leftmost zero. All versions in an object must 
            use the same version numbering layout which can be easily determined by looking at one existing 
            version: if the digit following <code>v</code> is a zero then the number format is zero padded to 
            fixed length, otherwise it is simply an integer.
        </p>
    </section>

</body>
</html>
