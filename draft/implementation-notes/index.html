<!DOCTYPE html>
<html lang="en">
<head>
    <title>Implementation Notes, Oxford Common File Layout Specification</title>
    <meta charset="utf-8">
    <meta name="description" content="Client Behaviours, Oxford Common File Layout Specification">
    <script src="../../respec-w3c-common.js"
            async class="remove"></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            shortName: "ocfl-spec",
            includePermalinks: true,
            editors: [
                {
                    name: "Andrew Hankinson",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Neil Jefferies",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Rosalyn Metz",
                    company: "Emory University",
                    companyURL: "https://web.library.emory.edu/"
                },
                {
                    name: "Julian Morley",
                    company: "Stanford University",
                    companyURL: "https://library.stanford.edu/"
                },
                {
                    name: "Simeon Warner",
                    url: "https://orcid.org/0000-0002-7970-7855",
                    company: "Cornell University",
                    companyURL: "https://www.library.cornell.edu/"
                },
                {
                    name: "Andrew Woods",
                    company: "DuraSpace",
                    companyURL: "http://duraspace.org/"
                }
            ],
            edDraftURI: "https://ocfl.io/draft/implementation-notes/",
            wg: "Oxford Common File Layout Editors",
            wgURI: "https://ocfl.io",
            wgPublicList: "",
            otherLinks: [{
                key: "Previous version",
                data: [
                    {
                        value: "N/A"
                    }
                ]
            }, {
                key: "Repository",
                data: [
                    {
                        value: "Github",
                        href: "https://github.com/ocfl/spec"
                    },
                    {
                        value: "Issues",
                        href: "https://github.com/ocfl/spec/issues"
                    },
                    {
                        value: "Commits",
                        href: "https://github.com/ocfl/spec/commits"
                    },
                    {
                        value: "Use Cases",
                        href: "https://github.com/ocfl/Use-Cases"
                    }
                ]
            }],
            maxTocLevel: 3,
            logos: [{
                src: "https://avatars0.githubusercontent.com/u/35607965",
                alt: "OCFL Logo",
                width: 307,
                height: 307
            }],
            overrideCopyright: '<p class="copyright">This document is licensed under a ' +
                '<a class="subfoot" href="https://creativecommons.org/licenses/by/4.0/" rel="license">' +
                'Creative Commons Attribution 4.0 License</a>.</p>',
            localBiblio: {
                "NAMASTE": {
                    title: "Directory Description with Namaste Tags",
                    href: "https://confluence.ucop.edu/download/attachments/14254149/NamasteSpec.pdf",
                    authors: [
                        "J. Kunze"
                    ],
                    date: "9 November 2009"
                },
                "OAIS": {
                    title: " Reference Model for an Open Archival Information System (OAIS), Issue 2",
                    href: "https://public.ccsds.org/pubs/650x0m2.pdf",
                    date: "June 2012"
                },
                "JSON-LD-1.1": {
                    title: "JSON-LD 1.1: A JSON-based Serialization for Linked Data",
                    href: "https://json-ld.org/spec/latest/json-ld/",
                    authors: [
                        "Manu Sporny", "Dave Longley", "Gregg Kellogg", "Markus Lanthaler", "Niklas Lindstr√∂m"
                    ],
                    date: "7 June 2018"
                }
            }
        };
    </script>
    <style>
        em.rfc2119 {
            text-transform: lowercase;
            font-variant: small-caps;
            font-style: normal;
            color: #900;
        }
    </style>
</head>
<body>
<section id="abstract" class="informative">
    <h2>Introduction</h2>
    <p>
        This document provides guidance to OCFL implementers for how clients should behave when operating on
        OCFL Objects.
    </p>
</section>

<section>
<h2>Rebuildability</h2>
<p>
A key goal of OCFL is the rebuildability of a repository from an OCFL storage root without additional information
resources. Consequently, a key implementation consideration should be to ensure that OCFL objects contain all the
data and metadata required to achieve this. With reference to the [[OAIS]] model, this would include all the
descriptive, administrative, structural, representation, and preservation metadata relevant to the object.
</p>
</section><section>

<h2>Filesystem metadata</h2>
<p>
Filesystem metadata (e.g. permissions, access, and creation times) are not considered portable between filesystems
or preservable through file transfer operations. Nor can these attributes be validated in terms of fixity in a
consistent manner. As such, OCFL neither explicitly supports nor expects that these quanties remain consistent.
If retaining this metadata is important then files should either be encapsulated in a filesystem image format that
preserves this information, or the metadata extracted and stored explicitly in an additional file.
</p>
</section><section>

<h2>Empty Directories</h2>
<p>
OCFL preserves files and their content, with directories serving as a useful organizational convention. An empty
directory consists only of filesystem metadata and therefore, as noted above, is not amenable to direct
preservation in OCFL. If the preservation of empty directories is considered essential then the suggested route
is to insert a zero length file named <code>.keep</code> into the directory which will ensure directories are preserved
as part of the files' path.
</p>
</section><section>

<h2>Data and Metadata</h2>
<p>
OCFL object versions are composed of series of files/bitstreams but OCFL does not make any disctinction between
different types of files other than those reserved for OCFL functionality: the inventory, its digest file, and
conformance declaration files. It is possible, for example, to create separate data and metadata directories within
each version to help organize material but all files are treated equally for the purpose of OCFL validation and
management.
</p>
</section><section>

<h2>Storage</h2>
<p>
OCFL separates stored file paths from the logical location of these files' content in OCFL object versions. This is a
key feature that allows previous versions of objects to remain immutable but permitting deduplication, forward delta
differencing, and easy file renaming. Consequently, OCFL only requires that files added to any version of an OCFL
object must be stored somewhere within the relevant version directory, with a corresponding entry in the manifest
block. An entry in the state block determines the path and name of the file within that version by referencing the
manifest entry, not the actual path on disk.
</p><p>
The most transparent approach is to have the path used to store the file on disk the same as the path of the
file within the object when accessioned. This is readily understandable in terms of visual inspection of the
physical filesystem.
</p><p>
However, this is not always possible. For example, complex objects with deep file hierarchies may encounter
issues if they come from a fileystem that allows longer paths than are supported by the target OCFL system. In
this case, the decoupling between physical and logical file paths in OCFL allows the use of truncated paths
for storage while the full paths can be preserved in state block entries which are not length constrained.
</p><p>
Another use case is importing content from other repository systems which renames files on ingest and stores
them in a flat hierarchy. These can be imported, as is, and the original paths and file names recorded through
suitable state block entries rather than reconstructing a physical file layout. Of course, OCFL supports
ongoing use of such a methodology.
</p>
</section><section>

<h2>Version Immutability</h2>
<p>
Previous versions of an object should be considered immutable since the composition of later versions of an
object may be dependent on them. In addition, the assumtion of immutability ensures that copies of different
versions of an object remain cosistent with each other, avoiding issues with identifying canonicity and
reconcilitation.
</p><p>
One key consequence of this immutabilty is that manifest entries should never be deleted. New entries may be
created, and, if not deduplicating file content, additional references to copies of stored content may be added.
</p>
</section><section>

<h2>Basic File Operations</h2>
<p>
[information on deleting, renaming, updating should go here]
</p>
</section><section>

<h2>Deduplication</h2>
<p>
OCFL supports optional deduplication if a client ensures that all digests in the manifest block refer to a
single file path on disk. This entry is created the first time file content is stored in an object.
Subsequent references to that file content should then occur in the state block only. This can be determined by
computing the digests of incoming files and determining if they already exist in the manifest block. If
deduplication is carried out within an object then, for consistency, it is expected that Forward Delta
deduplication will also be used between object versions so subsequent references to duplicated content should
also refer back to the original manifest entry rather than updating it to include additional references.
</p>
</section><section>

<h2>Forward Delta</h2>
<p>
Forward delta differencing is a key, though optional, feature of OCFL that means that parts of an OCFL object
version that are unchanged from a previous version are not stored again. This has the potential to signficantly
improve storage efficiency when objects have multiple versions, whether through ongoing curatorial action or
the accessioning of updated material.
</p><p>
When a new version of an OCFL Object is created from an earlier version and a client wishes to implement forward
delta differencing, then the possible file operations are handled in the following manner:
</p>
<ul>
<li>Unchanged files inherited from the previous version are referenced in the state block of the new version.
These entries will be indentical to the corresponding entries in the previous version's state object.</li>
<li>Files renamed from the previous version are referenced in the state block of the new version. The state
block entry with the name still points to the same manifest entry.</li>
<li>Files updated from the previous version are referenced in the state block of the new version. If the file
content, as determined by its digest, corresponds to an existing manifest entry then the state block should
point to it (it is possible that the updated file has the same content as a file other than the original).
Otherwise, the file should be stored and a new entry for the updated content must be made in the manifest
block of the object.</li>
<li>Files deleted from the previous version are simply not included in the state block of the new version.</li>
<li>File re-instated from earlier versions are referenced in the state block of the new version. These entries
will be indentical to the corresponding entries in the earlier version's state object.</li>
<li>New files added are referenced in the state block of the new version. If the file content, as determined
by its digest, corresponds to an existing manifest entry then the state block should point to it. Otherwise, the
file should be stored and a new entry for the updated content must be made in the manifest block of the object.</li>
</ul>
</section><section>

<h2>Fixity</h2>
<p>
The digests in the manifest are used by OCFL for content addressability rather than fixity but they are
suitable for use as part of a fixity regime, and the manifest usefully identifies all the files in an object.
Additional fixity entries may be made in the <a href="../spec/#fixity">fixity block</a> which permits a broader range
of algorithms but has the same layout as a manifest block. OCFL will consider the fixity block valid provided that the
files referenced in the block exist but OCFL cannot, reasonably, validate the hashes themselves. The fixity block does
not have to include all the files in an object to permit legacy fixity to be imported without requiring continued use
of obsolete digest algorithms.
</p>
</section><section>

<h2>File Purging</h2>
<p>
Sometimes a file needs to be deleted from all versons of an object, perhaps for legal reasons. Doing this to
an OCFL object breaks the previous version immutability assumption and is not supported directly. The correct
way to do this is to create a new object that excludes the offending file with a revised version history taking
this into account. The original object can then be deleted in its entirety. Creating the new object first is
good practice as it avoids any risk of data loss that may occur if an object were to be deleted before the new object
is created. The new object will be unlikely to have the same identifier as the original object so the deleted object can
be replaced by a stub object that directs users and software to the new version.
</p>
</section><section>

<h2>Log Information</h2>
<p>
There may be the need to record some actions on objects that do not result in changes to the object content.
For example, copying the object to new storage or validating fixity and finding nothing amiss. The <code>log</code>
directory is the location in an OCFL object where such events can be recorded. OCFL does not make any assumptions
about the contents of this directory but, if it exists, then its contents will not be subject any validation
processes.
</p>
</section><section>

<h2>Version Numbering</h2>
<p>
Version numbering should start with 1 and be positive sequential integers. Names start with a lower case
<code>v</code>. The numbers may be zero padded to the left to give fixed length, but, if used, zero padded
numbers must always retain at least one leftmost zero. All versions in an object must use the same version
numbering layout which can be easily determined by looking at one existing version &#x2014; if the digit
following <code>v</code> is a zero then the number format is zero padded to fixed length, otherwise it
is simply an integer.
</p>
</section><section>

<h2>Storage Root Heirarchy</h2>
<p>

</p>
</section>
</body>
</html>
