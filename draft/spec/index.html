<!DOCTYPE html>
<html lang="en">
<head>
    <title>Oxford Common File Layout Specification</title>
    <meta charset="utf-8"/>
    <meta name="description" content="Oxford Common File Layout Specification"/>
    <script src="../respec-w3c-common.js"
            async class="remove"></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            shortName: "ocfl-spec",
            includePermalinks: true,
            editors: [
                {
                    name: "Andrew Hankinson",
                    url: "https://orcid.org/0000-0003-2663-0003",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Neil Jefferies",
                    url: "https://orcid.org/0000-0003-3311-3741",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Rosalyn Metz",
                    url: "https://orcid.org/0000-0003-3526-2230",
                    company: "Emory University",
                    companyURL: "https://web.library.emory.edu/"
                },
                {
                    name: "Julian Morley",
                    url: "https://orcid.org/0000-0003-4176-1933",
                    company: "Stanford University",
                    companyURL: "https://library.stanford.edu/"
                },
                {
                    name: "Simeon Warner",
                    url: "https://orcid.org/0000-0002-7970-7855",
                    company: "Cornell University",
                    companyURL: "https://www.library.cornell.edu/"
                },
                {
                    name: "Andrew Woods",
                    url: "https://orcid.org/0000-0002-8318-4225",
                    company: "LYRASIS",
                    companyURL: "https://lyrasis.org/"
                }
            ],
            edDraftURI: "https://ocfl.io/draft/spec/",
            wg: "Oxford Common File Layout Editors",
            wgURI: "https://ocfl.io",
            wgPublicList: "",
            otherLinks: [{
                key: "Previous version",
                data: [
                    {
                        value: "N/A"
                    }
                ]
            }, {
                key: "Repository",
                data: [
                    {
                        value: "Github",
                        href: "https://github.com/ocfl/spec"
                    },
                    {
                        value: "Issues",
                        href: "https://github.com/ocfl/spec/issues"
                    },
                    {
                        value: "Commits",
                        href: "https://github.com/ocfl/spec/commits"
                    },
                    {
                        value: "Use Cases",
                        href: "https://github.com/ocfl/Use-Cases"
                    }
                ]
            }],
            maxTocLevel: 3,
            logos: [{
                src: "https://avatars0.githubusercontent.com/u/35607965",
                alt: "OCFL Logo",
                width: 307,
                height: 307
            }],
            overrideCopyright: '<p class="copyright">This document is licensed under a ' +
                '<a class="subfoot" href="https://creativecommons.org/licenses/by/4.0/" rel="license">' +
                'Creative Commons Attribution 4.0 License</a>.<br/>' +
                '<a class="copyright" href="https://avatars0.githubusercontent.com/u/35607965">' +
                'OCFL logo: hand-drive</a>" by <a href="http://orcid.org/0000-0001-8390-6171">Patrick Hochstenbach' +
                '</a> is licensed under <a href="https://creativecommons.org/licenses/by/2.0/">CC BY 2.0</a>.</p>',
            localBiblio: {
                "BagIt": {
                    title: "The BagIt File Packaging Format (V1.0)",
                    href: "https://tools.ietf.org/html/draft-kunze-bagit-17",
                    authors: [
                        "J. Kunze",
                        "J. Littman",
                        "E. Madden",
                        "J. Scancella",
                        "C. Adams"
                    ],
                    date: "17 September 2018"
                },
                "Digest-Algorithms-Extension": {
                    title: "OCFL Community Extension 0001: Digest Algorithms",
                    href: "https://ocfl.github.io/extensions/0001-digest-algorithms.html",
                    authors: [
                        "OCFL Editors"
                    ]
                },
                "Moab": {
                    title: "The Moab Design for Digital Object Versioning",
                    href: "https://journal.code4lib.org/articles/8482",
                    authors: [
                        "Richard Anderson"
                    ],
                    date: "15 July 2013"
                },
                "NAMASTE": {
                    title: "Directory Description with Namaste Tags",
                    href: "https://confluence.ucop.edu/download/attachments/14254149/NamasteSpec.pdf",
                    authors: [
                        "J. Kunze"
                    ],
                    date: "9 November 2009"
                },
                "OAIS": {
                    title: " Reference Model for an Open Archival Information System (OAIS), Issue 2",
                    href: "https://public.ccsds.org/pubs/650x0m2.pdf",
                    date: "June 2012"
                },
                "OCFL-Implementation-Notes": {
                    title: "OCFL Implementation Notes",
                    href: "../implementation-notes"
                },
                "PairTree": {
                  title: "Pairtrees for Object Storage",
                  href: "https://confluence.ucop.edu/display/Curation/PairTree",
                  authors: [
                    "J. Kunze", "M. Haye", "E. Hetzner", "M. Reyes", "C. Snavely"
                  ],
                  date: "12 August 2008"
                },
                "JSON-Schema": {
                    title: "JSON Schema Validation: A Vocabulary for Structural Validation of JSON",
                    href: "https://json-schema.org/latest/json-schema-validation.html",
                    authors: [
                      "A. Wright", "H Andrews"
                    ],
                    date: "20 September 2018"
                }
            }
        };
    </script>
    <style>
        em.rfc2119 {
            text-transform: lowercase;
            font-variant: small-caps;
            font-style: normal;
            color: #900;
        }
    </style>
</head>
<body>
<section id="abstract" class="informative">
  <h2>Introduction</h2>
  <p>
      This Oxford Common File Layout (OCFL) specification describes an application-independent approach to the storage
      of digital objects in a structured, transparent, and predictable manner. It is designed to promote long-term
      access and management of digital objects within digital repositories.
  </p>
    <section id="need">
        <h2>Need</h2>
        <p>
          The OCFL initiative began as a discussion amongst digital repository practitioners to identify well-defined,
          common, and application-independent file management for a digital repository's persisted objects and
          represents a specification of the community’s collective recommendations addressing five primary
          requirements: completeness, parsability, versioning, robustness, and storage diversity.
        </p>
        <section id="completeness">
            <h3>Completeness</h3>
            <p>
              The OCFL recommends storing metadata and the content it describes together so the OCFL object can be fully
              understood in the absence of original software. The OCFL does not make recommendations about what
              constitutes an object, nor does it assume what type of metadata is needed to fully understand the object,
              recognizing those decisions may differ from one repository to another. However, it is recommended that
              when making this decision, implementers consider what is necessary to rebuild the objects from the files
              stored.
            </p>
        </section>
        <section id="parsability">
            <h3>Parsability</h3>
            <p>
              One goal of the OCFL is to ensure objects remain fixed over time. This can be difficult as software and
              infrastructure change, and content is migrated. To combat this challenge, the OCFL ensures that both
              humans and machines can understand the layout and corresponding inventory regardless of the software or
              infrastructure used. This allows for humans to read the layout and corresponding inventory, and understand
              it without the use of machines. Additionally, if existing software were to become obsolete, the OCFL could
              easily be understood by a light weight application, even without the full feature repository that might
              have been used in the past.
            </p>
        </section>
        <section id="versioning">
            <h3>Versioning</h3>
            <p>
              Another need expressed by the community was the need to update and change objects, either the content
              itself or the metadata associated with the object. The OCFL relies heavily on the prior art in the
              [[Moab]] Design for Digital Object Versioning which utilizes forward deltas to track the history of the
              object. Utilizing this schema allows implementers of the OCFL to easily recreate past versions of an OCFL
              object. Like with objects, the OCFL remains silent on when versioning should occur recognizing this may
              differ from implementation to implementation.
            </p>
        </section>
        <section id="robustness">
            <h3>Robustness</h3>
            <p>
              The OCFL also fills the need for robustness against errors, corruption, and migration. The versioning
              schema ensures an OCFL object is robust enough to allow for the discovery of human errors. The fixity
              checking built into the OCFL via content addressable storage allows implementers to identify file
              corruption that might happen outside of normal human interactions. The OCFL eases content migrations by
              providing a technology agnostic method for verifying OCFL objects have remained fixed.
            </p>
        </section>
        <section id="storage-diversity">
            <h3>Storage diversity</h3>
            <p>
              Finally, the community expressed a need to store content on a wide variety of storage technologies. With
              that in mind, the OCFL was written with an eye toward various storage infrastructures including cloud
              object stores.
            </p>
        </section>
    </section>
    <section id="note">
      <h2>Note</h2>
      <p>
          This normative specification describes the nature of an OCFL Object (the "object-at-rest") and the
          arrangement of OCFL Objects under an OCFL Storage Root. A set of recommendations for how OCFL Objects should
          be acted upon (the "object-in-motion") can be found in the [[OCFL-Implementation-Notes]]. The OCFL editorial
          group recommends reading both the specification and the implementation notes in order to understand the full
          scope of the OCFL.
      </p>
      <p>
          This specification is designed to operate on storage systems that employ a hierarchical metaphor for
          presenting data to users. On traditional disk-based storage this may take the form of files and directories,
          and this is the terminology we use in this specification since it is widely known. However, it may equally
          apply to object stores, where namespaces, containers, and objects present a similar organization hierarchy to
          users.
      </p>
    </section>

</section>

<section id="sotd">
</section>

<section id="conformance">
</section>

<section id="terminology">
    <h2>Terminology</h2>
    <dl>
        <dt><dfn>Content Path</dfn>:</dt>
        <dd>
            The file path of a file on disk or in an object store, relative to the <a>OCFL Object Root</a>. Content
            paths are used in the <a>Manifest</a> within an <a>Inventory</a>.
        </dd>
        <dt>
            <dfn>Digest</dfn>:
        </dt>
        <dd>
            An algorithmic characterization of the contents of a file conforming to a standard digest algorithm.
        </dd>
        <dt>
            <dfn>Extension</dfn>:
        </dt>
        <dd>
            Extensions are used to collaborate, review, and publish additional non-normative functions related to OCFL.
            Extensions are intended to be informational and cite-able, but outside the scope of the normal specification
            process. Existing extensions may be found in the <a href="https://ocfl.github.io/extensions/">OCFL
            Extensions repository.</a>
        </dd>
        <dt>
            <dfn>Inventory</dfn>:
        </dt>
        <dd>
            A file, expressed in JSON, that tracks the history and current state of an OCFL Object.
        </dd>
        <dt>
            <dfn>Logical Path</dfn>:
        </dt>
        <dd>
            A path that represents a file's location in the <a>logical state</a> of an object. Logical paths are
            used in conjunction with a digest to represent the file name and path for a given bitstream at a given
            version.
        </dd>
        <dt>
            <dfn>Logical State</dfn>:
        </dt>
        <dd>
            A grouping of logical paths tied to their corresponding bitstreams that reflect the state of the
            object content for a given version.
        </dd>
        <dt>
            <dfn>Logs Directory</dfn>:
        </dt>
        <dd>
            A directory for storing information about the content (e.g., actions performed) that is not part of the
            content itself.
        </dd>
        <dt>
            <dfn>Manifest</dfn>
        </dt>
        <dd>
            A section of the <a>Inventory</a> listing all files and their digests within an OCFL Object.
        </dd>
        <dt>
            <dfn>OCFL Object</dfn>:
        </dt>
        <dd>
            A group of one or more content files and administrative information, that together have a unique identifier.
            The object may contain a sequence of versions of the files that represent the evolution of the object's
            contents.
        </dd>
        <dt>
            <dfn>OCFL Object Root</dfn>:
        </dt>
        <dd>
            The base directory of an <a>OCFL Object</a>, identified by a [[NAMASTE]] file "0=ocfl_object_1.0".
        </dd>
        <dt>
            <dfn>OCFL Storage Root</dfn>:
        </dt>
        <dd>
            A base directory used to store OCFL Objects, identified by a [[NAMASTE]] file "0=ocfl_1.0".
        </dd>
        <dt>
            <dfn>OCFL Version</dfn>:
        </dt>
        <dd>
            The state of an <a>OCFL Object</a>'s content which is constructed using the incremental changes recorded in
            the sequence of corresponding and prior version directories.
        </dd>
    </dl>
</section>

<section id="object-spec">
    <h2>OCFL Object</h2>
    <p>
        An OCFL Object is a group of one or more content files and administrative information, that are together
        identified by a URI. The object may contain a sequence of versions of the files that represent the evolution
        of the object's contents.
    </p>
    <p>
        A file is defined as a content bitstream that can be stored and transmitted. Directories (also called "folders")
        allow for the organization of files into tree-like hierarchies. The content of an OCFL Object is the files and
        the directories they are organized in that are stored <i>within</i> the hierarchy layout described in this
        specification.
    </p>
    <p>
        An OCFL Object includes administrative information that identifies a directory as an OCFL Object, and also
        provides a means of tracking changes to the contents of the object over time.
    </p>
    <p>
        An OCFL Object is therefore:
    </p>
    <ol>
        <li>A conceptual gathering of all files (data and metadata), the directories they are organized in, and their
            changes over time which together form the digital representation of an entity that need to be managed, in
            preservation terms, as a single coherent whole (i.e., content); and</li>
        <li>A file and directory layout and administrative information on a storage medium that provides a defined
            structure for the storage of this content, and through which these files and their changes may be understood
            (i.e., structure).</li>
    </ol>
    <p>
        A key goal of the OCFL is the rebuildability of a repository from an OCFL Storage Root without additional
        information resources. Consequently, a key implementation consideration should be to ensure that OCFL Objects
        contain all the data and metadata required to achieve this. With reference to the [[OAIS]] model, this would
        include all the descriptive, administrative, structural, representation and preservation metadata relevant
        to the object.
    </p>
    <p>
        A central feature of the OCFL specification is support for versioning. This recognizes that digital objects will
        change over time, through new requirements, fixes, updates, or format shifts. The specification takes no
        position on what constitutes a version or a versionable action, but it is recommended that implementers have a
        clear position on this within their local storage policies.
    </p>

    <section id="object-structure">
        <h2>Object Structure</h2>
        <p>
            The OCFL Object structure organizes content files and administrative information in order to support
            content storage and object validation. The structure for an object with one version is shown in the
            following figure:
        </p>
<pre>
[object_root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    └── v1
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
               └── ... content files ...
</pre>
        <p>
            The <a>OCFL Object Root</a> <span id="E001">MUST NOT</span> contain files or directories other than those
            specified in the following sections.
        </p>
    </section>

    <section id="object-conformance-declaration">
        <h2>Object Conformance Declaration</h2>
        <p>
            The version declaration <span id="E002">MUST</span> be formatted according to the [[!NAMASTE]]
            specification.
            It <span id="E003">MUST</span> be a file in the base directory of the OCFL Object Root giving the OCFL
            version in the filename. The filename <span id="E004">MUST</span> conform to the pattern
            <code>T=dvalue</code>, where <code>T</code> <span id="E005">MUST</span> be 0, and <code>dvalue</code>
            <span id="E006">MUST</span> be <code>ocfl_object_</code>, followed by the OCFL specification version
            number. The text contents of the file <span id="E007">MUST</span> be the same as <code>dvalue</code>,
            followed by a newline (<code>\n</code>).
        </p>
    </section>

    <section id="version-directories">
        <h2>Version Directories</h2>
        <p>
            OCFL Object content <span id="E008">MUST</span> be stored as a sequence of one or more versions. Each
            object version is stored in a version directory under the object root. The sequence of version numbers
            is the sequence of positive, base-ten integers: 1, 2, 3, etc., and the version directory name is
            constructed by adding the prefix <code>v</code>. The version number sequence <span id="E009">MUST</span>
            start at 1 and <span id="E010">MUST</span> be continuous without missing integers.
        </p>
        <p>
            Implementations <span id="W001">SHOULD</span> use version directory names constructed without zero-padding
            the version number, ie. <code>v1</code>, <code>v2</code>, <code>v3</code>, etc..
        </p>
        <p>
            For compatibility with existing filesystem conventions, implementations MAY use zero-padded version
            directory numbers, with the following restriction: If zero-padded version directory numbers are used then
            they <span id="E011">MUST</span> start with the prefix <code>v</code> and then a zero. For example, in an
            implementation that uses five digits for version directory names then <code>v00001</code> to
            <code>v09999</code> are allowed, <code>v10000</code> is not allowed.
        </p>
        <p>
            The first version of an object defines the naming convention for all version directories for the object.
            All version directories of an object <span id="E012">MUST</span> use the same naming convention: either a
            non-padded version directory number, or a zero-padded version directory number of consistent length.
            Operations that add a new version to an object <span id="E013">MUST</span> follow the version directory
            naming convention established by earlier versions. In all cases, references to files inside version
            directories from inventory files <span id="E014">MUST</span> use the actual version directory names.
        </p>
        <p>
            There <span id="E015">MUST</span> be no other files as children of a version directory, other than an <a
            href="#inventory">inventory file</a> and a <a href="#inventory-digest">inventory digest</a>.
            The version directory <span id="W002">SHOULD NOT</span> contain any directories other than the designated
            content sub-directory. Once created, the contents of a version directory are expected to be immutable.
        </p>
        <section id="content-directory">
          <h2>Content Directory</h2>
          <p>
              Version directories <span id="E016">MUST</span> contain a designated content sub-directory if the version
              contains files to be preserved, and <span id="W003">SHOULD NOT</span> contain this sub-directory
              otherwise. The name of this designated sub-directory MAY be defined in the
              <a href="#inventory">inventory file</a> using the key <code>contentDirectory</code> with the value being
              the chosen sub-directory name as a string, relative to the version directory. The
              <code>contentDirectory</code> value <span id="E017">MUST NOT</span> contain the forward slash
              (<code>/</code>) path separator and <span id="E018">MUST NOT</span> be either one or two periods
              (<code>.</code> or <code>..</code>). If the key <code>contentDirectory</code> is set, it
              <span id="E019">MUST</span> be set in the first version of the object and
              <span id="E020">MUST NOT</span> change between versions of the same object.
            </p>
          <p>
              If the key <code>contentDirectory</code> is not present in the <a href="#inventory">inventory file</a>
              then the name of the designated content sub-directory <span id="E021">MUST</span> be
              <code>content</code>. OCFL-compliant tools (including any validators) <span id="E022">MUST</span>
              ignore all directories in the object version directory except for the designated content directory.
          </p>
          <p>
              Every file within a version's content directory <span id="E023">MUST</span> be referenced in the
              <a href="#manifest">manifest</a> section of the inventory. There <span id="E024">MUST NOT</span> be empty
              directories within a version's content directory. A directory that would otherwise be empty MAY be
              maintained by creating a file within it named according to local conventions, for example by making an
              empty <code>.keep</code> file.
          </p>
        </section>
    </section>

    <section id="digests">
        <h2>Digests</h2>
        <p>
            Digests play two roles in an OCFL Object. The first is that digests allow for content-addressable
            reference to files within the OCFL Object. That is, the connection between a file's <a>content
            path</a> on physical storage and its <a>logical path</a> in a version of the object's content is made
            with a digest of its contents, rather than its filename. This use of the content digest facilitates
            de-duplication of files with the same content within an object, such as files that are unchanged from
            one version to the next. The second role that digests play is provide for fixity checks to determine
            whether a file has become corrupt, through hardware degradation or accident for example.
        </p>
        <p>
            For content-addressing, OCFL Objects <span id="E025">MUST</span> use either <code>sha512</code> or
            <code>sha256</code>, and <span id="W004">SHOULD</span> use <code>sha512</code>. The choice of the
            <code>sha512</code> digest algorithm as default recognizes that it has no known collision vulnerabilities
            and multiple implementations are available.
        </p>
        <p>
            For storage of additional fixity values, or to support legacy content migration, implementers
            <span id="E026">MUST</span> choose from the following controlled vocabulary of digest algorithms, or from a
            list of additional algorithms given in the [[Digest-Algorithms-Extension]]. OCFL clients
            <span id="E027">MUST</span> support all fixity algorithms given in the table below, and MAY support
            additional algorithms from the extensions. Optional fixity algorithms that are not supported by a client
            <span id="E028">MUST</span> be ignored by that client.
        </p>
        <table class="simple" id="digest-algorithms">
            <thead>
            <tr>
                <th>Digest Algorithm Name</th>
                <th>Note</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><code>md5</code></td>
                <td>Insecure. Use only for legacy fixity values. MD5 algorithm and hex encoding defined by
                    [[!RFC1321]]. For example, the <code>md5</code> digest of a zero-length bitstream is
                    <code>d41d8cd98f00b204e9800998ecf8427e</code>.</td>
            </tr>
            <tr>
                <td><code>sha1</code></td>
                <td>Insecure. Use only for legacy fixity values. SHA-1 algorithm defined by [[!FIPS-180-4]]
                    and <span id="E029">MUST</span> be encoded using hex (base16) encoding [[!RFC4648]].
                    For example, the <code>sha1</code> digest of a zero-length bitstream is
                    <code>da39a3ee5e6b4b0d3255bfef95601890afd80709</code>.</td>
            </tr>
            <tr>
                <td><code>sha256</code></td>
                <td>Non-truncated form only; note performance implications. SHA-256 algorithm defined by
                    [[!FIPS-180-4]] and <span id="E030">MUST</span> be encoded using hex (base16) encoding [[!RFC4648]].
                    For example, the <code>sha256</code> digest of a zero-length bitstream starts
                    <code>e3b0c44298fc1c149afbf4c8996fb92427ae41e4...</code> (64 hex digits long).</td>
            </tr>
            <tr>
                <td><code>sha512</code></td>
                <td>Default choice. Non-truncated form only. SHA-512 algorithm defined by [[!FIPS-180-4]] and
                    <span id="E031">MUST</span> be encoded using hex (base16) encoding [[!RFC4648]].
                    For example, the <code>sha512</code> digest of a zero-length bitstream starts
                    <code>cf83e1357eefb8bdf1542850d66d8007d620e405...</code> (128 hex digits long).</td>
            </tr>
            <tr>
                <td><code>blake2b-512</code></td>
                <td>Full-length form only, using the 2B variant (64 bit) as defined by [[!RFC7693]].
                    <span id="E032">MUST</span> be encoded using hex (base16) encoding [[!RFC4648]]. For example, the
                    <code>blake2b-512</code> digest of a zero-length bitstream starts
                    <code>786a02f742015903c6c6fd852552d272912f4740...</code> (128 hex digits long).</td>
            </tr>
            </tbody>
        </table>
        <p>
            An OCFL Inventory MAY contain a fixity section that can store one or more blocks containing fixity values
            using multiple digest algorithms. See the <a href="#fixity">section on fixity</a> below for further details.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: Implementers may also store copies of their file digests in a system external to
                their OCFL Object stores at the point of ingest, to further safeguard against the possibility of
                malicious manipulation of file contents and digests.
            </p>
            <p>
                Implementers should be aware that base16 digests are case insensitive. Different tools will generate
                digests in uppercase or lowercase, and this may lead to case differences between references to a digest
                and the digest itself within the inventory. If string-based methods are used to work with digests
                and inventories (as is the case in most common JSON libraries) then extra care must be taken to ensure
                case-insensitive comparisons are being made.
            </p>
        </blockquote>
    </section>

    <section id="inventory">
        <h2>Inventory</h2>
        <p>
            An OCFL Object Inventory <span id="E033">MUST</span> follow the [[!JSON]] structure described in this
            section and <span id="E034">MUST</span> be named <code>inventory.json</code>. The order of entries in both
            the [[JSON]] objects and arrays used in inventory files has no significance.
        </p>
        <p>
            The forward slash (/) path separator <span id="E035">MUST</span> be used in content paths in the
            <a href="#manifest">manifest</a> and <a href="#fixity">fixity</a> blocks within the inventory.
            Implementations that target systems using other separators will need to translate paths appropriately.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: A [[JSON-Schema]] for validating OCFL Object Inventory files is provided at
                <a href="inventory_schema.json">inventory_schema.json</a>.
            </p>
        </blockquote>
        <section id="inventory-structure">
            <h2>Basic Structure</h2>
            <p>
                An OCFL Object Inventory <span id="E036">MUST</span> include the following keys:
            </p>
            <dl>
                <dt><code>id</code></dt>
                <dd>
                    A unique identifier for the OCFL Object. This <span id="E037">MUST</span> be unique in the local
                    context, and <span id="W005">SHOULD</span> be a URI [[!RFC3986]]. There is no expectation that a
                    URI used is resolvable. For example, URNs [[RFC8141]] MAY be used.
                </dd>
                <dt><code>type</code></dt>
                <dd>
                    A type for the inventory JSON object that also serves to document the OCFL specification version
                    that the inventory complies with. This <span id="E038">MUST</span> be the URI of the inventory
                    section of the specification, <code>https://ocfl.io/1.0/spec/#inventory</code>.
                </dd>
                <dt><code>digestAlgorithm</code></dt>
                <dd>
                    The digest algorithm used for calculating digests for content-addressing within the OCFL Object
                    and for the <a href="#inventory-digest">Inventory Digest</a>. This <span id="E039">MUST</span> be
                    the algorithm used in the <code>manifest</code> and <code>state</code> blocks, see the
                    <a href="#digests">section on Digests</a> for more information about algorithms.
                </dd>
                <dt><code>head</code></dt>
                <dd>
                    The version directory name of the most recent version of the object. This
                    <span id="E040">MUST</span> be the version directory name with the highest version number.
                </dd>
            </dl>
            <p>
                There MAY be the following key:
            </p>
            <dl>
                <dt><code>contentDirectory</code></dt>
                <dd>
                    The name of the designated content directory within the version directories. If not specified then
                    the content directory name is <code>content</code>.
                </dd>
            </dl>
            <p>
                In addition to these keys, there <span id="E041">MUST</span> be two other blocks present,
                <code>manifest</code> and <code>versions</code>, which are discussed in the next two sections.
            </p>
        </section>

        <section id="manifest">
            <h2>Manifest</h2>
            <p>
                The value of the <code>manifest</code> key is a JSON object, with keys corresponding to the digests
                of every content file in all versions of the <a>OCFL Object</a>. The value for each key
                <span id="E092">MUST</span> be an array containing the <a>content path</a>s of files in the OCFL
                Object that have content with the given digest. Content paths within a manifest block
                <span id="E042">MUST</span> be relative to the <a>OCFL Object Root</a>.
            </p>
            <blockquote class="informative">
                <p>
                    Non-normative note: If only one file is stored in the OCFL Object for each digest, fully
                    de-duplicating the content, then there will be only one <a>content path</a> for each digest.
                    There may, however, be multiple logical paths for a given digest if the content was not entirely
                    de-duplicated when constructing the OCFL Object.
                </p>
                <p>
                    An example manifest object for three content paths, all in version 1, is shown below:
                </p>
<pre>
  "manifest": {
    "7dcc35...c31": [ "v1/content/foo/bar.xml" ],
    "cf83e1...a3e": [ "v1/content/empty.txt" ],
    "ffccf6...62e": [ "v1/content/image.tiff" ]
  }
</pre>
            </blockquote>
        </section>

        <section id="versions">
            <h2>Versions</h2>
            <p>
                An OCFL Object Inventory <span id="E043">MUST</span> include a block for storing versions. This block
                <span id="E044">MUST</span> have the key of <code>versions</code> within the inventory, and it
                <span id="E045">MUST</span> be a JSON object. The keys of this object <span id="E046">MUST</span>
                correspond to the names of the <a href="#version-directories">version directories</a> used. Each
                value <span id="E047">MUST</span> be another JSON object that characterizes the version, as described
                in the <a href="#version"></a> section.
            </p>
            <section id="version">
                <h2>Version</h2>
                <p>
                    A JSON object to describe one <a>OCFL Version</a>, which <span id="E048">MUST</span> include the
                    following keys:
                </p>
                <dl>
                    <dt>
                        <code>created</code>
                    </dt>
                    <dd>
                        The value of this key is the datetime of creation of this version. It
                        <span id="E049">MUST</span> be expressed in the Internet Date/Time Format defined by
                        [[!RFC3339]]. This format requires the inclusion of a timezone value or <code>Z</code> for UTC,
                        and that the time component be granular to the second level (with optional fractional seconds).
                    </dd>
                    <dt>
                        <code>state</code>
                    </dt>
                    <dd>
                        <p>
                            The value of this key is a JSON object, containing a list of keys and values corresponding
                            to the <a>logical state</a> of the object at that version. The keys of this JSON object
                            are digest values, each of which <span id="E050">MUST</span> correspond to an entry in the
                            <a href="#manifest">manifest of the inventory</a>. The value for each key is an array
                            containing <a>logical path</a> names of files in the OCFL Object state that have
                            content with the given digest.
                        </p>
                        <p>
                            <a href="#logical-path">Logical paths</a> present the structure of an OCFL Object at a
                            given version. This is given as an array of values, with the following restrictions to
                            provide for path safety in the common case of the logical path value representing a file
                            path.
                        </p>    
                            <ul>
                                <li>The logical path <span id="E051">MUST</span> be interpreted as a set of one or more
                                    path elements joined by a <code>/</code> path separator.</li>
                                <li>Path elements <span id="E052">MUST NOT</span> be <code>.</code>, <code>..</code>, 
                                    or empty (<code>//</code>).</li>
                                <li>A logical path <span id="E053">MUST NOT</span> begin or end with a forward slash 
                                    (<code>/</code>).</li>
                                <li>Within a version, logical paths <span id="E095">MUST</span> be unique and 
                                    non-conflicting, so the logical path for a file cannot appear as the initial part
                                    of another logical path.</li>
                            </ul>
                        <blockquote class="informative">
                            <p>
                                Non-normative note: The <a>logical state</a> of the object uses content-addressing
                                to map logical paths to their bitstreams, as expressed in the manifest
                                section of the inventory. Notably, the version state provides de-duplication of content
                                within the OCFL Object by mapping multiple logical paths with the same content to
                                the same digest in the manifest. See [[OCFL-Implementation-Notes]].
                            </p>
                            <p>
                                An example state block is shown below:
                            </p>
<pre>
  "state": {
    "4d27c8...b53": [ "foo/bar.xml" ],
    "cf83e1...a3e": [ "empty.txt", "empty2.txt" ]
  }
</pre>
                            <p>
                                This state block describes an object with 3 files, two of which have the same content
                                (<code>empty.txt</code> and <code>empty2.txt</code>), and one of which is in a
                                sub-directory (<code>bar.xml</code>). The <a>logical state</a> shown as a tree
                                is thus:
                            </p>
<pre>
    ├── empty.txt
    ├── empty2.txt
    └── foo
        └── bar.xml
</pre>
                        </blockquote>
                    </dd>
                </dl>
                <p>
                    The JSON object describing an <a>OCFL Version</a>, <span id="W007">SHOULD</span> include the
                    following keys:
                </p>
                <dl>
                    <dt>
                        <code>message</code>
                    </dt>
                    <dd>
                        The value of this key is freeform text, used to record the rationale for creating this version.
                    </dd>
                    <dt>
                        <code>user</code>
                    </dt>
                    <dd>
                        The value of this key is a JSON object intended to identify the user or agent that created the
                        current <a>OCFL Version</a>.
                        The value of the <code>user</code> key <span id="E054">MUST</span> contain a user name key,
                        <code>name</code> and <span id="W008">SHOULD</span> contain an address key,
                        <code>address</code>. The <code>name</code> value is any readable name of the user, e.g., a
                        proper name, user ID, agent ID. The <code>address</code> value <span id="W009">SHOULD</span> be
                        a URI: either a mailto URI [[RFC6068]] with the e-mail address of the user or a URL to a
                        personal identifier, e.g., an ORCID iD.
                    </dd>
                </dl>
            </section>
        </section>

        <section id="fixity">
            <h2>Fixity</h2>
            <p>
                An OCFL Object inventory MAY include a block for storing additional fixity information to supplement the
                complete set of digests in the <a href="#manifest">Manifest</a>, for example to support legacy digests
                from a content migration. This block <span id="E055">MUST</span> have the key of <code>fixity</code>
                within the inventory.
            </p>
            <p>
                The <code>fixity</code> block <span id="E056">MUST</span> contain keys corresponding to the controlled
                vocabulary given in the <a href="#digest-algorithms">digest algorithms</a> listed in the
                <a href="#digests">Digests</a> section, or in a table given in an <a>Extension</a>. The value of the
                fixity block for a particular digest algorithm <span id="E057">MUST</span> follow the structure of the
                <a href="#manifest"><code>manifest</code></a> block; that is, a key corresponding to the digest value,
                and an array of <a>content path</a>s. The fixity block for any digest algorithm MAY include digest
                values for any subset of content paths in the object. Where included, the digest values given
                <span id="E093">MUST</span> match the digests of the files at the corresponding content paths. There
                is no requirement that all content files have a value in the fixity block, or that fixity values
                provided in one version are carried forward to later versions.
            </p>
            <blockquote class="informative">
            <p>
                An example fixity block with <code>md5</code> and <code>sha1</code> digests is shown below. In this
                case the <code>md5</code> digest values are provided only for version 1 content paths.
            </p>
<pre>
  "fixity": {
    "md5": {
      "184f84e28cbe75e050e9c25ea7f2e939": [ "v1/content/foo/bar.xml" ],
      "c289c8ccd4bab6e385f5afdd89b5bda2": [ "v1/content/image.tiff" ],
      "d41d8cd98f00b204e9800998ecf8427e": [ "v1/content/empty.txt" ]
    },
    "sha1": {
      "66709b068a2faead97113559db78ccd44712cbf2": [ "v1/content/foo/bar.xml" ],
      "a6357c99ecc5752931e133227581e914968f3b9c": [ "v2/content/foo/bar.xml" ],
      "b9c7ccc6154974288132b63c15db8d2750716b49": [ "v1/content/image.tiff" ],
      "da39a3ee5e6b4b0d3255bfef95601890afd80709": [ "v1/content/empty.txt" ]
    }
  }
</pre>
            </blockquote>
        </section>
    </section>

    <section id="inventory-digest">
        <h2>Inventory Digest</h2>
        <p>
            Every occurrence of an inventory file <span id="E058">MUST</span> have an accompanying sidecar file named
            <code>inventory.json.ALGORITHM</code> stating its digest, where <code>ALGORITHM</code> is the chosen digest
            algorithm for the object. The ALGORITHM <span id="E059">MUST</span> match the value given for the
            <code>digestAlgorithm</code> key in the inventory. An example might be <code>inventory.json.sha512</code>.
        </p>
        <p>
            The digest sidecar file <span id="E060">MUST</span> contain the digest of the inventory file. This
            <span id="E061">MUST</span> follow the format:
        </p>
<pre>
DIGEST inventory.json
</pre>
        <p>
            One or more whitespace characters (spaces or tabs) must separate DIGEST from the string
            <code>inventory.json</code>; that is, the name of the inventory file in the same directory.
        </p>
        <p>
            The digest of the inventory <span id="E062">MUST</span> be computed only after all changes to the inventory
            have been made, and thus writing the digest sidecar file is the last step in the versioning process.
        </p>
    </section>

    <section id="version-inventory">
        <h2>Version Inventory and Inventory Digest</h2>
        <p>
            Every OCFL Object <span id="E063">MUST</span> have an inventory file within the OCFL Object Root,
            corresponding to the state of the OCFL Object at the current version. Additionally, every version directory
            <span id="W010">SHOULD</span> include an inventory file that is an <a href="#inventory">Inventory</a> of
            all content for versions up to and including that particular version. Where an OCFL Object contains
            <code>inventory.json</code> in version directories, the inventory file in the OCFL Object Root
            <span id="E064">MUST</span> be the same as the file in the most recent version. See also requirements for
            the corresponding <a href="#inventory-digest">Inventory Digest</a>.
        </p>
        <p>
            In the case that prior version directories include an inventory file there will be multiple inventory
            files describing prior versions within the OCFL Object. Each version block in each prior inventory file
            <span id="E066">MUST</span> represent the same object state as the corresponding version block in the
            current inventory file. Additionally, the values of the <code>created</code>, <code>message</code> and
            <code>user</code> keys in each version block in each prior inventory file <span id="W011">SHOULD</span>
            have the same values as the corresponding keys in the corresponding version block in the current inventory
            file.
        </p>
        <blockquote class="informative">
            Non-normative note: Storing an inventory for every version provides redundancy for this critical
            information in a way that is compatible with storage strategies that have immutable version directories.
        </blockquote>
    </section>

    <section id="logs-directory">
        <h2>Logs Directory</h2>
        <p>
            The base directory of an OCFL Object MAY contain a directory named <code>logs</code>, which MAY be empty.
            Implementers <span id="W012">SHOULD</span> use this for storing files that contain a record of actions
            taken on the object. Since these logs may be subject to local standards requirements, the format of these
            logs is considered out-of-scope for the OCFL Object. Clients operating on the object MAY log actions here
            that are not otherwise captured.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: The purpose of the logs directory is to provide implementers with a location for
                storing local information about actions to the OCFL Object's content that is not part of the content
                itself.
            </p>
            <p>
                As an example, implementers may have different local requirements to store audit information for their
                content. Some may wish to store a log entry indicating that an audit was conducted, and nothing was
                wrong, while others may wish to only store a log entry if an intervention was required.
            </p>
        </blockquote>
    </section>

    <section id="object-extensions">
        <h2>Object Extensions</h2>
        <p>
            The base directory of an OCFL Object MAY contain a directory named <code>extensions</code> for the purposes
            of extending the functionality of an OCFL Object. The <code>extensions</code> directory
            <span id="E067">MUST NOT</span> contain any files, and no sub-directories other than extension
            sub-directories. Extension sub-directories <span id="W013">SHOULD</span> be named according to a registered
            extension name. The specific structure and function of the extension, as well as a declaration of the
            registered extension name <span id="E068">MUST</span> be defined in one of the following locations:
        </p>
        <ul>
          <li>
            The <a href="https://ocfl.github.io/extensions/">OCFL Extensions repository</a>
          </li>
          <li>
            The Storage Root, as a plain text document directly in the Storage Root
          </li>
        </ul>
        <blockquote class="informative">
          <p>
            Non-normative note: Extension sub-directories should use the same name as a registered extension
            in order to both avoid the possiblity of an extension sub-directory colliding with the name of another
            registered extension as well as to facilitate the recognition of extensions by OCFL clients.
          </p>
        </blockquote>
    </section>
</section>

<section id="storage-root">
    <h2>OCFL Storage Root</h2>
    <p>
      An <a>OCFL Storage Root</a> is the base directory of an OCFL storage layout.
    </p>

    <section id="root-structure">
        <h2>Root Structure</h2>
        <p>
          An OCFL Storage Root <span id="E069">MUST</span> contain a
          <a href="#root-conformance-declaration">Root Conformance Declaration</a> identifying it as such.
        </p>
        <p>
          An OCFL Storage Root MAY contain other files. These might include a human-readable copy of the OCFL
          specification to make the storage root self-documenting, or files used by <a href="#root-extensions">storage
          root extensions</a>.
        </p>
        <p>
          An OCFL Storage Root MAY contain a JSON file named <code>ocfl_layout.json</code> to describe the arrangement
          of directories and OCFL objects under the storage root. If present, this JSON document
          <span id="E070">MUST</span> include the following two keys in the root JSON object:
        </p>
        <ul>
          <li>
            <code>key</code> - A key identifying the precise arrangement of directories and OCFL objects under the
            storage root, i.e. how OCFL object identifiers are mapped to directory hierarchies. The value of this key
            is not defined in the OCFL specification, but <span id="E071">MUST</span> correspond to a value given in an
            <a>Extension</a>.
          </li>
          <li>
            <code>description</code> - A human readable description of the arrangement of directories and OCFL
            objects under the storage root.
          </li>
        </ul>
        <p>
          Sub-directories within an OCFL Storage Root <span id="E072">MUST NOT</span> contain files that are not part
          of an OCFL Object. Empty directories <span id="E073">MUST NOT</span> appear within a storage root.
        </p>
        <p>
          Although implementations may require multiple OCFL Storage Roots&mdash;that is, several logical or
          physical volumes, or multiple "buckets" in an object store&mdash;each OCFL Storage Root
          <span id="E074">MUST</span> be independent.
        </p>
        <p>
          The following example OCFL Storage Root represents the minimal set of files and folders:
        </p>
        <pre>
[storage_root]
    ├── 0=ocfl_1.0
    ├── ocfl_1.0.txt (human-readable text of the OCFL specification; optional)
    └── ocfl_layout.json (description of storage hierarchy layout; optional)
        </pre>
    </section>

    <section id="root-conformance-declaration">
        <h2>Root Conformance Declaration</h2>
        <p>
          The OCFL version declaration <span id="E075">MUST</span> be formatted according to the [[!NAMASTE]]
          specification. It <span id="E076">MUST</span> be a file in the base directory of the <a>OCFL Storage Root</a>
          giving the OCFL version in the filename. The filename <span id="E077">MUST</span> conform to the pattern
          <code>T=dvalue</code>, where <code>T</code> <span id="E078">MUST</span> be 0, and <code>dvalue</code>
          <span id="E079">MUST</span> be <code>ocfl_</code>, followed by the OCFL specification version number. The
          text contents of the file <span id="E080">MUST</span> be the same as <code>dvalue</code>, followed by a
          newline (<code>\n</code>).
        </p>
        <p>
          Root conformance indicates that the OCFL Storage Root conforms to this section (i.e. the OCFL Storage Root
          section) of the specification. OCFL Objects within the OCFL Storage Root also include a conformance
          declaration which <span id="E081">MUST</span> indicate OCFL Object conformance to the same or earlier version
          of the specification.
        </p>
    </section>

    <section id="root-hierarchies">
        <h2>Storage Hierarchies</h2>
        <p>
          <a>OCFL Object Root</a>s <span id="E082">MUST</span> be stored either as the terminal resource at the end of
          a directory storage hierarchy or as direct children of a containing <a>OCFL Storage Root</a>.
        </p>
        <p>
          A common practice is to use a unique identifier scheme to compose this storage hierarchy, typically arranged
          according to some form of the [[PairTree]] specification. Irrespective of the pattern chosen for the storage
          hierarchies, the following restrictions apply:
        </p>
        <ol>
          <li>There <span id="E083">MUST</span> be a deterministic mapping from an object identifier to a unique
            storage path</li>
          <li>Storage hierarchies <span id="E084">MUST NOT</span> include files within intermediate directories</li>
          <li>Storage hierarchies <span id="E085">MUST</span> be terminated by OCFL Object Roots</li>
          <li>Storage hierarchies within the same OCFL Storage Root <span id="W014">SHOULD</span> use just one layout
            pattern</li>
          <li>Storage hierarchies within the same OCFL Storage Root <span id="W015">SHOULD</span> consistently use
            either a directory hierarchy of OCFL Objects or top-level OCFL Objects</li>
        </ol>
    </section>

    <section id="storage-root-extensions">
        <h2>Storage Root Extensions</h2>
        <p>
            The behavior of the storage root may be extended to support features from other specifications.
        </p>
        <p>
            The base directory of an OCFL Storage Root MAY contain a directory named <code>extensions</code> for the
            purposes of extending the functionality of an OCFL Storage Root. The storage root <code>extensions</code>
            directory <span id="E086">MUST</span> conform to the same guidelines and limitations as those defined for
            <a href="#object-extensions">object extensions</a>.
        </p>
        <p>
            An OCFL validator <span id="E087">MUST</span> ignore any files in the storage root it does not understand.
            Additional files <span id="E088">MUST NOT</span> appear in other directories under the storage root.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: Storage extensions can be used to support additional features, such as providing
                the storage hierarchy disposition when pairtree is in use, or additional human-readable text about the
                nature of the storage root.
            </p>
        </blockquote>
    </section>

    <section id="filesystem-features">
        <h2>Filesystem features</h2>
        <p>
            In order to maximize the compatibility of the OCFL with different filesystems, and thus improve the
            portability of OCFL Objects between different systems, some restrictions on the use of certain
            filesystem features are necessary. If the preservation of non-OCFL-compliant features is required then
            the content <span id="E089">MUST</span> be wrapped in a suitable disk or filesystem image format which OCFL
            can treat as a regular file.
        </p>
        <ol>
          <li>Filesystem metadata (e.g. permissions, access, and creation times) are not considered portable between
              filesystems or preservable through file transfer operations. These attributes also cannot be validated in
              terms of fixity in a consistent manner. As such, the OCFL does not support the portability of these
              attributes.</li>
          <li>Hard and soft (symbolic) links are not portable and <span id="E090">MUST NOT</span> be used within OCFL
              Storage hierachies. A common use case for links is storage deduplication. OCFL inventories provide a
              portable method of achieving the same effect by using digests to address content.</li>
          <li>File paths and filenames in the OCFL are case sensitive. Filesystems <span id="E091">MUST</span> preserve
              the case of OCFL filepaths and filenames.</li>
          <li>Transparent filesystem features such as compression and encryption should be effectively invisible to
              OCFL operations. Consequently, they should not be expected to be portable.</li>
        </ol>
    </section>

</section>

<section id="examples" class="informative">
    <h2>Examples</h2>

    <section id="example-minimal-object">
        <h2>Minimal OCFL Object</h2>
        <p>
            The following example OCFL Object has content that is a single file
            (<code>file.txt</code>), and just one version (<code>v1</code>):
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    └── v1
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
            └── file.txt
</pre>
        <p>
            The inventory for this OCFL Object, the same both at the top-level and
            in the <code>v1</code> directory, might be:
        </p>
<pre id="example-minimal-inventory">
{
  "digestAlgorithm": "sha512",
  "head": "v1",
  "id": "http://example.org/minimal",
  "manifest": {
    "7545b8...f67": [ "v1/content/file.txt" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2018-10-02T12:00:00Z",
      "message": "One file",
      "state": {
        "7545b8...f67": [ "file.txt" ]
      },
      "user": {
        "address": "alice@example.org",
        "name": "Alice"
      }
    }
  }
}
</pre>
    </section>

    <section id="example-versioned-object">
        <h2>Versioned OCFL Object</h2>
        <p>
            The following example OCFL Object has three versions:
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    ├── v1
    │   ├── inventory.json
    │   ├── inventory.json.sha512
    │   └── content
    │       ├── empty.txt
    │       ├── foo
    │       │   └── bar.xml
    │       └── image.tiff
    ├── v2
    │   ├── inventory.json
    │   ├── inventory.json.sha512
    │   └── content
    │       └── foo
    │           └── bar.xml
    └── v3
        ├── inventory.json
        └── inventory.json.sha512


</pre>
        <p>
            In <code>v1</code> there are three files, <code>empty.txt</code>, <code>foo/bar.xml</code>,
            and <code>image.tiff</code>. In <code>v2</code> the content of <code>foo/bar.xml</code> is changed,
            <code>empty2.txt</code> is added with the same content as <code>empty.txt</code>, and
            <code>image.tiff</code> is removed. In <code>v3</code> the file <code>empty.txt</code> is
            removed, and <code>image.tiff</code> is reinstated. As a result of forward-delta versioning, the
            object tree above shows only new content added in each version. The inventory shown below details
            the other changes, includes additional fixity information using <code>md5</code> and
            <code>sha1</code> digest algorithms, and minimal metadata for each version.
        </p>
<pre id="example-versioned-inventory">
{
  "digestAlgorithm": "sha512",
  "fixity": {
    "md5": {
      "184f84e28cbe75e050e9c25ea7f2e939": [ "v1/content/foo/bar.xml" ],
      "2673a7b11a70bc7ff960ad8127b4adeb": [ "v2/content/foo/bar.xml" ],
      "c289c8ccd4bab6e385f5afdd89b5bda2": [ "v1/content/image.tiff" ],
      "d41d8cd98f00b204e9800998ecf8427e": [ "v1/content/empty.txt" ]
    },
    "sha1": {
      "66709b068a2faead97113559db78ccd44712cbf2": [ "v1/content/foo/bar.xml" ],
      "a6357c99ecc5752931e133227581e914968f3b9c": [ "v2/content/foo/bar.xml" ],
      "b9c7ccc6154974288132b63c15db8d2750716b49": [ "v1/content/image.tiff" ],
      "da39a3ee5e6b4b0d3255bfef95601890afd80709": [ "v1/content/empty.txt" ]
    }
  },
  "head": "v3",
  "id": "ark:/12345/bcd987",
  "manifest": {
    "4d27c8...b53": [ "v2/content/foo/bar.xml" ],
    "7dcc35...c31": [ "v1/content/foo/bar.xml" ],
    "cf83e1...a3e": [ "v1/content/empty.txt" ],
    "ffccf6...62e": [ "v1/content/image.tiff" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2018-01-01T01:01:01Z",
      "message": "Initial import",
      "state": {
        "7dcc35...c31": [ "foo/bar.xml" ],
        "cf83e1...a3e": [ "empty.txt" ],
        "ffccf6...62e": [ "image.tiff" ]
      },
      "user": {
        "address": "alice@example.com",
        "name": "Alice"
      }
    },
    "v2": {
      "created": "2018-02-02T02:02:02Z",
      "message": "Fix bar.xml, remove image.tiff, add empty2.txt",
      "state": {
        "4d27c8...b53": [ "foo/bar.xml" ],
        "cf83e1...a3e": [ "empty.txt", "empty2.txt" ]
      },
      "user": {
        "address": "bob@example.com",
        "name": "Bob"
      }
    },
    "v3": {
      "created": "2018-03-03T03:03:03Z",
      "message": "Reinstate image.tiff, delete empty.txt",
      "state": {
        "4d27c8...b53": [ "foo/bar.xml" ],
        "cf83e1...a3e": [ "empty2.txt" ],
        "ffccf6...62e": [ "image.tiff" ]
      },
      "user": {
        "address": "cecilia@example.com",
        "name": "Cecilia"
      }
    }
  }
}
</pre>
    </section>

    <section id="example-object-diff-paths">
        <h2>Different Logical and Content Paths in an OCFL Object</h2>
        <p>
            The following example OCFL Object inventory shows how content paths may differ from logical paths.
            The example object has just one version, <code>v1</code>, which has two files with logical paths
            <code>a file.wxy</code> and <code>another file.xyz</code> as shown in the <code>state</code> block.
            The corresponding content paths are <code>v1/content/3bacb119a98a15c5</code> and
            <code>v1/content/9f2bab8ef869947d</code> respectively, as shown in the <code>manifest</code>.
            Except for location within the appropriate version directory, <code>v1/content</code> in this example,
            the OCFL specification does not constrain the choice of content paths used when creating or
            updating an OCFL object. The choice might depend on particular limitations of, or optimizations for, the
            target storage system, or on portability considerations. Any compliant implementation will be able to
            recover version state with the original logical paths.
        </p>
<pre id="example-diff-paths-inventory">
{
  "digestAlgorithm": "sha512",
  "head": "v1",
  "id": "http://example.org/diff-paths",
  "manifest": {
    "7545b8...f67": [ "v1/content/3bacb119a98a15c5" ],
    "af318d...3cd": [ "v1/content/9f2bab8ef869947d" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2019-03-14T20:31:00Z",
      "state": {
        "7545b8...f67": [ "a file.wxy" ],
        "af318d...3cd": [ "another file.xyz" ]
      }
    }
  }
}
</pre>
    </section>

    <section id="example-bagit-in-ocfl">
        <h2>BagIt in an OCFL Object</h2>
        <p>
            [[BagIt]] is a common file packaging specification, but unlike the OCFL it does not provide a mechanism for
            content versioning. Using the OCFL it is possible to store a BagIt structure with content versioning, such
            that when the object state is resolved, it creates a valid BagIt 'bag'. This example will illustrate one way
            this can be accomplished, using the <a href="https://tools.ietf.org/html/draft-kunze-bagit-17#section-4.1">
            example of a basic bag</a> given in the BagIt specification.
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    └── v1
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
            └── myfirstbag
                ├── bagit.txt
                ├── data
                │   └── 27613-h
                │       └── images
                │           ├── q172.png
                │           └── q172.txt
                └── manifest-md5.txt
</pre>

        <p>
            If, for example, a new directory were added in a subsequent version, the OCFL Object would look like this:
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    ├── v1
    │   ├── inventory.json
    │   ├── inventory.json.sha512
    │   └── content
    │       └── myfirstbag
    │           ├── bagit.txt
    │           ├── data
    │           │   └── 27613-h
    │           │       └── images
    │           │           ├── q172.png
    │           │           └── q172.txt
    │           └── manifest-md5.txt
    └── v2
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
            └── myfirstbag
                ├── data
                │   └── 27614-h
                │       └── images
                │           ├── q173.png
                │           └── q173.txt
                └── manifest-md5.txt
</pre>
        <p>
            The state of the object at version 2 would be the following BagIt object:
        </p>
<pre>
myfirstbag
    ├── bagit.txt
    ├── data
    │   ├── 27613-h
    │   │   └── images
    │   │       ├── q172.png
    │   │       └── q172.txt
    │   └── 27614-h
    │       └── images
    │           ├── q173.png
    │           └── q173.txt
    └── manifest-md5.txt
</pre>
        <p>
            The OCFL Inventory for this object would be as follows:
        </p>
<pre id="example-bagit-inventory">
{
  "digestAlgorithm": "sha512",
  "head": "v2",
  "id": "urn:uri:example.com/myfirstbag",
  "manifest": {
    "cf83e1...a3e": [ "v1/content/myfirstbag/bagit.txt" ],
    "f15428...83f": [ "v1/content/myfirstbag/manifest-md5.txt" ],
    "85f2b0...007": [ "v1/content/myfirstbag/data/27613-h/images/q172.png" ],
    "d66d80...8bd": [ "v1/content/myfirstbag/data/27613-h/images/q172.txt" ],
    "2b0ff8...620": [ "v2/content/myfirstbag/manifest-md5.txt" ],
    "921d36...877": [ "v2/content/myfirstbag/data/27614-h/images/q173.png" ],
    "b8bdf1...927": [ "v2/content/myfirstbag/data/27614-h/images/q173.txt" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2018-10-09T11:20:29.209164Z",
      "message": "Initial Ingest",
      "state": {
        "cf83e1...a3e": [ "myfirstbag/bagit.txt" ],
        "85f2b0...007": [ "myfirstbag/data/27613-h/images/q172.png" ],
        "d66d80...8bd": [ "myfirstbag/data/27613-h/images/q172.txt" ],
        "f15428...83f": [ "myfirstbag/manifest-md5.txt" ]
      },
      "user": {
        "address": "someone@example.org",
        "name": "Some One"
      }
    },
    "v2": {
      "created": "2018-10-31T11:20:29.209164Z",
      "message": "Added new images",
      "state": {
        "cf83e1...a3e": [ "myfirstbag/bagit.txt" ],
        "85f2b0...007": [ "myfirstbag/data/27613-h/images/q172.png" ],
        "d66d80...8bd": [ "myfirstbag/data/27613-h/images/q172.txt" ],
        "2b0ff8...620": [ "myfirstbag/manifest-md5.txt" ],
        "921d36...877": [ "myfirstbag/data/27614-h/images/q173.png" ],
        "b8bdf1...927": [ "myfirstbag/data/27614-h/images/q173.txt" ]
      },
      "user": {
        "address": "somebody-else@example.org",
        "name": "Somebody Else"
      }
    }
  }
}
</pre>
    </section>

    <section id="example-moab-in-ocfl">
        <h2>Moab in an OCFL Object</h2>
        <p>
            [[Moab]] is an archive information package format developed and used by Stanford University.
            Many of the ideas in Moab have been refined by the OCFL, and the OCFL is designed to
            give institutions currently using Moab an easy path to adoption.
        </p>
        <p>
            Converting content preserved in a Moab object in a way that does not compromise existing Moab
            access patterns whilst allowing for the eventual use of OCFL-native workflows requires a Moab to
            OCFL conversion tool. This tool uses the Moab-versioning gem to extract deltas and digests
            of the Moab data directory for each Moab version and translate those into version state blocks
            in an OCFL inventory file, which would be placed in the root directory of the Moab object.
            The content of the <code>data</code> directory in the Moab version directories (and thus, the bitstreams
            that Moab is preserving) is tracked by OCFL, via the <code>contentDirectory</code> value.
            The contents of the Moab <code>manifests</code> directories are not tracked, as the intention is not
            to encapsulate a Moab object inside an OCFL object, but rather to migrate Moab's preserved
            bitstreams into an OCFL object without compromising legacy access patterns.
        </p>
        <p>
            During the transitionary period the OCFL inventory file exists only in the root of the Moab object.
            Once OCFL-native object creation workflows have been completed, future versions of that object will
            be fully OCFL compliant - new versions will no longer have a manifests directory and will contain an
            OCFL inventory file. At this stage OCFL tools will be able to access all versions of the content
            originally preserved by Moab.
        </p>
        <p>
            Consider the following sample Moab object:
        </p>
<pre>
[object root]
    └── bj102hs9687
        ├── v0001
        │     ├── data
        │     │   ├── content
        │     │   │   ├── eric-smith-dissertation-augmented.pdf
        │     │   │   └── eric-smith-dissertation.pdf
        │     │   └── metadata
        │     │       ├── contentMetadata.xml
        │     │       ├── descMetadata.xml
        │     │       ├── identityMetadata.xml
        │     │       ├── provenanceMetadata.xml
        │     │       ├── relationshipMetadata.xml
        │     │       ├── rightsMetadata.xml
        │     │       ├── technicalMetadata.xml
        │     │       └── versionMetadata.xml
        │     └── manifests
        │         ├── fileInventoryDifference.xml
        │         ├── manifestInventory.xml
        │         ├── signatureCatalog.xml
        │         ├── versionAdditions.xml
        │         └── versionInventory.xml
        ├── v0002
        │     ├── data
        │     │   └── metadata
        │     │       ├── contentMetadata.xml
        │     │       ├── embargoMetadata.xml
        │     │       ├── events.xml
        │     │       ├── identityMetadata.xml
        │     │       ├── provenanceMetadata.xml
        │     │       ├── relationshipMetadata.xml
        │     │       ├── rightsMetadata.xml
        │     │       ├── versionMetadata.xml
        │     │       └── workflows.xml
        │     └── manifests
        │         ├── fileInventoryDifference.xml
        │         ├── manifestInventory.xml
        │         ├── signatureCatalog.xml
        │         ├── versionAdditions.xml
        │         └── versionInventory.xml
        └── v0003
              ├── data
              │   └── metadata
              │       ├── contentMetadata.xml
              │       ├── descMetadata.xml
              │       ├── embargoMetadata.xml
              │       ├── events.xml
              │       ├── identityMetadata.xml
              │       ├── provenanceMetadata.xml
              │       ├── rightsMetadata.xml
              │       ├── technicalMetadata.xml
              │       ├── versionMetadata.xml
              │       └── workflows.xml
              └── manifests
                  ├── fileInventoryDifference.xml
                  ├── manifestInventory.xml
                  ├── signatureCatalog.xml
                  ├── versionAdditions.xml
                  └── versionInventory.xml
</pre>
        <p>
            An OCFL inventory that tracks the <code>data</code> directory would include a manifest comprised as follows.
            Note the absence of the <code>manifests</code> directory, as we are not encapsulating the Moab object
            in an OCFL object, and the presence of <code>contentDirectory</code> to specify <code>data</code> as the
            preserved content directory:
        </p>
<pre id="example-moab-inventory">
{
  "digestAlgorithm": "sha512",
  "head": "v3",
  "id": "druid:bj102hs9687",
  "contentDirectory": "data",
  "manifest": {
    "98114a...588": [ "v0001/data/content/eric-smith-dissertation-augmented.pdf" ],
    "7f3d87...15b": [ "v0001/data/content/eric-smith-dissertation.pdf" ],
    "6d19f0...064": [ "v0001/data/metadata/technicalMetadata.xml" ],
    "6e4be4...375": [ "v0001/data/metadata/provenanceMetadata.xml" ],
    "d8a319...d0f": [ "v0001/data/metadata/descMetadata.xml" ],
    "de823a...acc": [ "v0001/data/metadata/rightsMetadata.xml" ],
    "080617...40c": [ "v0001/data/metadata/identityMetadata.xml" ],
    "e15267...58d": [ "v0001/data/metadata/versionMetadata.xml" ],
    "0d9e0b...9a2": [ "v0001/data/metadata/contentMetadata.xml" ],
    "dd9289...31d": [ "v0001/data/metadata/relationshipMetadata.xml" ],
    "7519c5...63f": [ "v0002/data/metadata/provenanceMetadata.xml" ],
    "abda4c...622": [ "v0002/data/metadata/workflows.xml" ],
    "76549e...b2b": [ "v0002/data/metadata/rightsMetadata.xml" ],
    "bdc4d6...3b6": [ "v0002/data/metadata/events.xml" ],
    "7b331c...f9b": [ "v0002/data/metadata/identityMetadata.xml" ],
    "80ceac...b9c": [ "v0002/data/metadata/versionMetadata.xml" ],
    "4853a2...fbe": [ "v0002/data/metadata/contentMetadata.xml" ],
    "1d5090...f5f": [ "v0002/data/metadata/relationshipMetadata.xml" ],
    "f209bf...ceb": [ "v0002/data/metadata/embargoMetadata.xml" ],
    "dd9125...d4b": [ "v0003/data/metadata/technicalMetadata.xml" ],
    "d9e177...477": [ "v0003/data/metadata/provenanceMetadata.xml" ],
    "4f5908...4f5": [ "v0003/data/metadata/workflows.xml" ],
    "e64db0...500": [ "v0003/data/metadata/descMetadata.xml" ],
    "05fa51...818": [ "v0003/data/metadata/rightsMetadata.xml" ],
    "d70dd8...5ad": [ "v0003/data/metadata/events.xml" ],
    "509a2d...dc6": [ "v0003/data/metadata/identityMetadata.xml" ],
    "548066...893": [ "v0003/data/metadata/versionMetadata.xml" ],
    "93884e...aae": [ "v0003/data/metadata/contentMetadata.xml" ],
    "4c5ab4...b02": [ "v0003/data/metadata/embargoMetadata.xml" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2019-03-14T20:31:00Z",
      "state": {
        "98114a...588": [ "content/eric-smith-dissertation-augmented.pdf" ],
        "7f3d87...15b": [ "content/eric-smith-dissertation.pdf" ],
        "6d19f0...064": [ "metadata/technicalMetadata.xml" ],
        "6e4be4...375": [ "metadata/provenanceMetadata.xml" ],
        "d8a319...d0f": [ "metadata/descMetadata.xml" ],
        "de823a...acc": [ "metadata/rightsMetadata.xml" ],
        "080617...40c": [ "metadata/identityMetadata.xml" ],
        "e15267...58d": [ "metadata/versionMetadata.xml" ],
        "0d9e0b...9a2": [ "metadata/contentMetadata.xml" ],
        "dd9289...31d": [ "metadata/relationshipMetadata.xml" ]
      }
    },
    "v2": {
      "created": "2019-03-24T09:22:00Z",
      "state": {
        "98114a...588": [ "content/eric-smith-dissertation-augmented.pdf" ],
        "7f3d87...15b": [ "content/eric-smith-dissertation.pdf" ],
        "6d19f0...064": [ "metadata/technicalMetadata.xml" ],
        "7519c5...63f": [ "metadata/provenanceMetadata.xml" ],
        "d8a319...d0f": [ "metadata/descMetadata.xml" ],
        "76549e...b2b": [ "metadata/rightsMetadata.xml" ],
        "7b331c...f9b": [ "metadata/identityMetadata.xml" ],
        "80ceac...b9c": [ "metadata/versionMetadata.xml" ],
        "4853a2...fbe": [ "metadata/contentMetadata.xml" ],
        "1d5090...f5f": [ "metadata/relationshipMetadata.xml" ],
        "abda4c...622": [ "metadata/workflows.xml" ],
        "bdc4d6...3b6": [ "metadata/events.xml" ],
        "f209bf...ceb": [ "metadata/embargoMetadata.xml" ]
      }
    },
    "v3": {
      "created": "2019-04-02T11:07:00Z",
      "state": {
        "98114a...588": [ "content/eric-smith-dissertation-augmented.pdf" ],
        "7f3d87...15b": [ "content/eric-smith-dissertation.pdf" ],
        "dd9125...d4b": [ "metadata/technicalMetadata.xml" ],
        "d9e177...477": [ "metadata/provenanceMetadata.xml" ],
        "e64db0...500": [ "metadata/descMetadata.xml" ],
        "05fa51...818": [ "metadata/rightsMetadata.xml" ],
        "509a2d...dc6": [ "metadata/identityMetadata.xml" ],
        "548066...893": [ "metadata/versionMetadata.xml" ],
        "93884e...aae": [ "metadata/contentMetadata.xml" ],
        "1d5090...f5f": [ "metadata/relationshipMetadata.xml" ],
        "4f5908...4f5": [ "metadata/workflows.xml" ],
        "d70dd8...5ad": [ "metadata/events.xml" ],
        "4c5ab4...b02": [ "metadata/embargoMetadata.xml" ]
      }
    }
  }
}
</pre>
</section>
    <section id="example-extended-storage-root">
        <h2>Example Extended OCFL Storage Root</h2>
        <p>
            The following example OCFL Storage Root has an extension containing custom content. The OCFL Storage Root
            itself remains valid.
        </p>
<pre>
[storage root]
    ├── 0=ocfl_1.0
    ├── extensions
    │   └── 0000-example-extension
    │       └── file-example.txt
    ├── ocfl_1.0.txt
    └── ocfl_layout.json
</pre>
    </section>
    <section id="example-extended-object">
        <h2>Example Extended OCFL Object</h2>
        <p>
            The following example OCFL Object has an extension containing custom content. The OCFL Object itself
            remains valid.
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    ├── extensions
    │   └── 0000-example-extension
    │       └── file1-draft.txt
    └── v1
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
            └── file.txt
</pre>
    </section>
</section>
</body>
</html>
