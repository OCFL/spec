<!DOCTYPE html>
<html lang="en">
<head>
    <title>Oxford Common File Layout Specification</title>
    <meta charset="utf-8">
    <meta name="description" content="Oxford Common File Layout Specification">
    <script src="../respec-w3c-common.js"
            async class="remove"></script>
    <script class="remove">
        var respecConfig = {
            specStatus: "unofficial",
            shortName: "ocfl-spec",
            includePermalinks: true,
            editors: [
                {
                    name: "Andrew Hankinson",
                    url: "https://orcid.org/0000-0003-2663-0003",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Neil Jefferies",
                    url: "https://orcid.org/0000-0003-3311-3741",
                    company: "Bodleian Libraries, University of Oxford",
                    companyURL: "http://www.bodleian.ox.ac.uk/"
                },
                {
                    name: "Rosalyn Metz",
                    url: "https://orcid.org/0000-0003-3526-2230",
                    company: "Emory University",
                    companyURL: "https://web.library.emory.edu/"
                },
                {
                    name: "Julian Morley",
                    company: "Stanford University",
                    companyURL: "https://library.stanford.edu/"
                },
                {
                    name: "Simeon Warner",
                    url: "https://orcid.org/0000-0002-7970-7855",
                    company: "Cornell University",
                    companyURL: "https://www.library.cornell.edu/"
                },
                {
                    name: "Andrew Woods",
                    url: "https://orcid.org/0000-0002-8318-4225",
                    company: "DuraSpace",
                    companyURL: "http://duraspace.org/"
                }
            ],
            edDraftURI: "https://ocfl.io/draft/spec/",
            wg: "Oxford Common File Layout Editors",
            wgURI: "https://ocfl.io",
            wgPublicList: "",
            otherLinks: [{
                key: "Previous version",
                data: [
                    {
                        value: "N/A"
                    }
                ]
            }, {
                key: "Repository",
                data: [
                    {
                        value: "Github",
                        href: "https://github.com/ocfl/spec"
                    },
                    {
                        value: "Issues",
                        href: "https://github.com/ocfl/spec/issues"
                    },
                    {
                        value: "Commits",
                        href: "https://github.com/ocfl/spec/commits"
                    },
                    {
                        value: "Use Cases",
                        href: "https://github.com/ocfl/Use-Cases"
                    }
                ]
            }],
            maxTocLevel: 3,
            logos: [{
                src: "https://avatars0.githubusercontent.com/u/35607965",
                alt: "OCFL Logo",
                width: 307,
                height: 307
            }],
            overrideCopyright: '<p class="copyright">This document is licensed under a ' +
                '<a class="subfoot" href="https://creativecommons.org/licenses/by/4.0/" rel="license">' +
                'Creative Commons Attribution 4.0 License</a>.</p>',
            localBiblio: {
                "BagIt": {
                    title: "The BagIt File Packaging Format (V1.0)",
                    href: "https://tools.ietf.org/html/draft-kunze-bagit-17",
                    authors: [
                        "J. Kunze",
                        "J. Littman",
                        "E. Madden",
                        "J. Scancella",
                        "C. Adams"
                    ],
                    date: "17 September 2018"
                },
                "Moab": {
                    title: "The Moab Design for Digital Object Versioning",
                    href: "https://journal.code4lib.org/articles/8482",
                    authors: [
                        "Richard Anderson"
                    ],
                    date: "15 July 2013"
                },
                "NAMASTE": {
                    title: "Directory Description with Namaste Tags",
                    href: "https://confluence.ucop.edu/download/attachments/14254149/NamasteSpec.pdf",
                    authors: [
                        "J. Kunze"
                    ],
                    date: "9 November 2009"
                },
                "OAIS": {
                    title: " Reference Model for an Open Archival Information System (OAIS), Issue 2",
                    href: "https://public.ccsds.org/pubs/650x0m2.pdf",
                    date: "June 2012"
                },
                "Stop-Using-SHA-256": {
                  title: "Stop Using SHA-256",
                  href: "https://medium.com/@davidtstrauss/stop-using-sha-256-6adbb55c608",
                  authors: [
                    "David Timothy Strauss"
                  ],
                  date: "6 October 2017"
                },
                "OCFL-Implementation-Notes": {
                    title: "OCFL Implementation Notes",
                    href: "../implementation-notes"
                },
                "PairTree": {
                  title: "Pairtrees for Object Storage",
                  href: "https://confluence.ucop.edu/display/Curation/PairTree",
                  authors: [
                    "J. Kunze", "M. Haye", "E. Hetzner", "M. Reyes", "C. Snavely"
                  ],
                  date: "12 August 2008"
                },
                "JSON-Schema": {
                    title: "JSON Schema Validation: A Vocabulary for Structural Validation of JSON",
                    href: "https://json-schema.org/latest/json-schema-validation.html",
                    authors: [
                      "A. Wright", "H Andrews"
                    ],
                    date: "20 September 2018"
                }
            }
        };
    </script>
    <style>
        em.rfc2119 {
            text-transform: lowercase;
            font-variant: small-caps;
            font-style: normal;
            color: #900;
        }
    </style>
</head>
<body>
<section id="abstract" class="informative">
  <h2>Introduction</h2>
  <p>
      This Oxford Common File Layout (OCFL) specification describes an application-independent approach to the storage
      of digital objects in a structured, transparent, and predictable manner. It is designed to promote long-term
      access and management of digital objects within digital repositories.
  </p>
  <p>
      This normative specification describes the nature of an OCFL Object (the "object-at-rest") and the arrangement
      of OCFL Objects under an OCFL Storage Root. A set of recommendations for how OCFL Objects should be acted upon
      (the "object-in-motion") can be found in the [[OCFL-Implementation-Notes]].
  </p>
    <section id="need">
        <h2>Need</h2>
        <p>
          The OCFL initiative arose from a need to have well-defined application-independent file management within
          digital repositories.
        </p>
        <p>
          A general observation is that the contents of a digital repository &#8212; that is, the digital files and
          metadata that an institution might wish to manage &#8212; are largely stable. Once content has been
          accessioned, it is unlikely to change significantly over its lifetime. This is in contrast to the software
          applications that manage these contents, which are ephemeral, requiring constant updating and replacement.
          Thus, transitions between application-specific methods of file management to support software upgrades and
          replacement cycles can be seen as unnecessary and risky change which affects the long-term stable objects
          in support of the short-term, ephemeral software.
        </p>
        <p>
          By providing a specification for the file and directory layout on disk or in an object store, the OCFL is an
          attempt at reducing, or even eliminating, the need for these transitions. As an application-independent
          specification, conforming applications will natively "understand" the underlying file structure without
          needing to first transition these contents to their own format.
         </p>
        <p>
          While digital repository content changes relatively slowly, it is necessary to be able to track changes to 
          digital objects. Within the file and directory layout specification, OCFL provides a simple structure to 
          efficiently capture versions of object contents so that all previous states of an object may be recovered
          and examined.
        </p>
    </section>
</section>

<section id="sotd">
</section>

<section id="conformance">
</section>

<section id="terminology">
    <h2>Terminology</h2>
    <dl>
        <dt><dfn>Existing File Path</dfn>:</dt>
        <dd>
            The file path of a file on disk or in an object store, relative to the <a>OCFL Object Root</a>. Existing
            file paths are used in the <a>Manifest</a> within an <a>Inventory</a>.
        </dd>
        <dt>
            <dfn>Digest</dfn>:
        </dt>
        <dd>
            An algorithmic characterization of the contents of a file conforming to a standard digest algorithm.
        </dd>
        <dt>
            <dfn>Inventory</dfn>:
        </dt>
        <dd>
            A file, expressed in JSON, that tracks the history and current state of an OCFL Object.
        </dd>
        <dt>
            <dfn>Logical File Path</dfn>:
        </dt>
        <dd>
            A path that represents a file's location in the <a>logical state</a> of an object. Logical file paths are
            used in conjunction with a digest to represent the file name for a given bitstream at a given version.
        </dd>
        <dt>
            <dfn>Logical State</dfn>:
        </dt>
        <dd>
            A grouping of logical file paths tied to their corresponding bitstreams that reflect the state of the
            object content for a given version.
        </dd>
        <dt>
            <dfn>Logs Directory</dfn>:
        </dt>
        <dd>
            A directory for storing information about the content (e.g., actions performed) that is not part of the
            content itself.
        </dd>
        <dt>
            <dfn>Manifest</dfn>
        </dt>
        <dd>
            A section of the <a>Inventory</a> listing all files and their digests within an OCFL Object.
        </dd>
        <dt>
            <dfn>OCFL Object</dfn>:
        </dt>
        <dd>
            A group of one or more content files and administrative information, that are together identified by a URI.
            The object may contain a sequence of versions of the files that represent the evolution of the object's
            contents.
        </dd>
        <dt>
            <dfn>OCFL Object Root</dfn>:
        <dt>
        <dd>
            The base directory of an <a>OCFL Object</a>, identified by a [[NAMASTE]] file "0=ocfl_object_1.0".
        </dd>
        <dt>
            <dfn>OCFL Storage Root</dfn>:
        </dt>
        <dd>
            A base directory used to store OCFL Objects, identified by a [[NAMASTE]] file "0=ocfl_1.0".
        </dd>
        <dt>
            <dfn>OCFL Version</dfn>:
        <dt>
        <dd>
            The state of an <a>OCFL Object</a>'s content which is constructed using the incremental changes recorded in
            the sequence of corresponding and prior version directories.
        </dd>
    </dl>
</section>

<section id="object-spec">
    <h2>OCFL Object</h2>
    <p>
        An OCFL Object is a group of one or more content files and administrative information, that are together
        identified by a URI. The object may contain a sequence of versions of the files that represent the evolution
        of the object's contents.
    </p>
    <p>
        A file is defined as a content bitstream that can be stored and transmitted. Directories (also called "folders")
        allow for the organization of files into tree-like hierarchies. The content of an OCFL Object is the files and
        the directories they are organized in that are stored <i>within</i> the hierarchy layout described in this
        specification.
    </p>
    <p>
        An OCFL Object includes administrative information that identifies a directory as an OCFL Object, and also
        provides a means of tracking changes to the contents of the object over time.
    </p>
    <p>
        An OCFL Object is therefore:
    </p>
    <ol>
        <li>A conceptual gathering of all files (data and metadata), the directories they are organized in, and their
            changes over time which together form the digital representation of an entity that need to be managed, in
            preservation terms, as a single coherent whole (i.e., content); and</li>
        <li>A file and directory layout and administrative information on a storage medium that provides a defined
            structure for the storage of this content, and through which these files and their changes may be understood
            (i.e., structure).</li>
    </ol>
    <p>
        A key goal of OCFL is the rebuildability of a repository from an OCFL Storage Root without additional
        information resources. Consequently, a key implementation consideration should be to ensure that OCFL Objects
        contain all the data and metadata required to achieve this. With reference to the [[OAIS]] model, this would
        include all the descriptive, administrative, structural, representation and preservation metadata relevant
        to the object.
    </p>
    <p>
        A central feature of the OCFL specification is support for versioning. This recognizes that digital objects will
        change over time, through new requirements, fixes, updates, or format shifts. The specification takes no
        position on what constitutes a version or a versionable action, but it is recommended that implementers have a
        clear position on this within their local storage policies.
    </p>

    <section id="object-structure">
        <h2>Object Structure</h2>
        <p>
            The OCFL Object structure organizes content files and administrative information in order to support
            content storage and object validation. The structure for an object with one version is shown in the
            following figure:
        </p>
<pre>
[object_root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    └── v1
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
               └── ... content files ...
</pre>
    </section>

    <section id="object-conformance-declaration">
        <h2>Object Conformance Declaration</h2>
        <p>
            The version declaration MUST be formatted according to the [[!NAMASTE]] specification. It MUST be an empty
            file in the base directory of the object giving the OCFL Object version in the filename. The filename MUST
            be constructed with a leading zero-equals (<code>0=</code>) string, the string <code>ocfl_object_</code>,
            followed by the OCFL specification version number. For example <code>0=ocfl_object_1.0</code> for version
            1.0 of this specification.
        </p>
    </section>

    <section id="version-directories">
        <h2>Version Directories</h2>
        <p>
            OCFL Object content MUST be stored as a sequence of one or more versions. Each object version is stored in a
            version directory under the object root. The sequence of version numbers is the sequence of positive
            integers: 1, 2, 3, etc., and the version directory name is constructed by adding the prefix <code>v</code>.
        </p>
        <p>
            Implementations SHOULD use version directory names constructed without zero-padding the
            version number, ie. <code>v1</code>, <code>v2</code>, <code>v3</code>, etc..
        </p>
        <p>
            For compatibility with existing filesystem conventions, implementations MAY use zero-padded version
            directory numbers, with the following restriction: If zero-padded version directory numbers are used then
            they MUST start with the prefix <code>v</code> and then a zero. For example, in an implementation that uses
            five digits for version directory names then <code>v00001</code> to <code>v09999</code> are allowed,
            <code>v10000</code> is not allowed.
        </p>
        <p>
            The first version of an object defines the naming convention for all version directories for the object.
            All version directories of an object MUST use the same naming convention: either a non-padded version
            directory number, or a zero-padded version directory number of consistent length. Operations that add a new
            version to an object MUST follow the version directory naming convention established by earlier versions.
            In all cases, references to files inside version directories from inventory files MUST use the actual
            version directory names.
        </p>
        <p>
            Version directories MUST have a sub-directory called <code>content</code> if there are files present, and
            SHOULD NOT contain a <code>content</code> sub-directory otherwise. There MUST be no other files or
            directories as children of a version directory, other than an <a href="#inventory">inventory file</a>,
            an <a href="#inventory-digest">inventory digest</a>, and a <code>content</code> directory.
        </p>
        <p>
            Every file within a version's <code>content</code> directory MUST be referenced in the
            <a href="#manifest">manifest</a> section of the inventory. There MUST NOT be empty directories within
            a version's <code>content</code> directory. A directory that would otherwise be empty MAY be maintained
            by creating file within it named according to local conventions, for example by making an empty
            <code>.keep</code> file.
        </p>
    </section>

    <section id="digests">
        <h2>Digests</h2>
        <p>
            Digests play two roles in an OCFL Object. The first is that digests allow for content-addressable
            storage; that is, for a file to be addressed by the digest of its contents, rather than its filename.
            The second is that digests provide for fixity checks to determine whether a file has become corrupt
            through hardware degradation, accident, or malicious actors.
        </p>
        <p>
            For content-addressing, OCFL Objects MUST use either <code>sha512</code> or <code>sha256</code> 
            digests, and SHOULD use <code>sha512</code> digests. The choice of the <code>sha512</code> digest
            algorithm recognizes that it has no known collision vulnerabilities and is less computationally
            intensive to compute than <code>sha256</code>, [[Stop-Using-SHA-256]].
        </p>
        <p>
            For storage of additional fixity values, and perhaps to support legacy content migration, implementers
            MAY choose from the following list of digest algorithms:
        </p>
        <table class="simple" id="digest-algorithms">
            <thead>
            <tr>
                <th>Digest Algorithm</th>
                <th>Note</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><code>md5</code></td>
                <td>Insecure. Use only for legacy fixity values. MD5 algorithm and hex encoding defined by
                    [[!RFC1321]]. For example, the <code>md5</code> digest of a zero-length bitstream is
                    <code>d41d8cd98f00b204e9800998ecf8427e</code>.</td>
            </tr>
            <tr>
                <td><code>sha1</code></td>
                <td>Insecure. Use only for legacy fixity values. SHA-1 algorithm defined by [[!FIPS-180-4]]
                    and MUST be encoded using hex (base16) encoding [[!RFC4648]].
                    For example, the <code>sha1</code> digest of a zero-length bitstream is
                    <code>da39a3ee5e6b4b0d3255bfef95601890afd80709</code>.</td>
            </tr>
            <tr>
                <td><code>sha256</code></td>
                <td>Non-truncated form only; note performance implications. SHA-256 algorithm defined by
                    [[!FIPS-180-4]] and MUST be encoded using hex (base16) encoding [[!RFC4648]].
                    For example, the <code>sha256</code> digest of a zero-length bitstream starts
                    <code>e3b0c44298fc1c149afbf4c8996fb92427ae41e4...</code> (64 hex digits long).</td>
            </tr>
            <tr>
                <td><code>sha512</code></td>
                <td>Default choice. Non-truncated form only. SHA-512 algorithm defined by [[!FIPS-180-4]] and
                    MUST be encoded using hex (base16) encoding [[!RFC4648]].
                    For example, the <code>sha512</code> digest of a zero-length bitstream starts
                    <code>cf83e1357eefb8bdf1542850d66d8007d620e405...</code> (128 hex digits long).</td>
            </tr>
            </tbody>
        </table>
        <p>
            An OCFL Inventory MAY contain a fixity section that can store one or more blocks containing fixity values
            using multiple digest algorithms. See the <a href="#fixity">section on fixity</a> below for further details.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: Implementers may also store copies of their file digests in a system external to
                their OCFL Object stores at the point of ingest, to further safeguard against the possibility of
                malicious manipulation of file contents and digests.
            </p>
            <p>
                Implementers should be aware that base16 digests are case insensitive. Different tools will generate
                digests in uppercase or lowercase, and this may lead to case differences between references to a digest
                and the digest itself within the inventory. If string-based methods are used to work with digests
                and inventories (as is the case in most common JSON libraries) then extra care must be taken to ensure
                case-insensitive comparisons are being made.
            </p>
        </blockquote>
    </section>

    <section id="inventory">
        <h2>Inventory</h2>
        <p>
            An OCFL Object Inventory MUST follow the [[!JSON]] structure described in this section and MUST be named
            <code>inventory.json</code>. The order of entries in both the [[JSON]] objects and arrays used in inventory
            files has no significance.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: A [[JSON-Schema]] for validating OCFL Object Inventory files is provided at
                <a href="inventory_schema.json">inventory_schema.json</a>.
            </p>
        </blockquote>
        <section id="inventory-structure">
            <h2>Basic Structure</h2>
            <p>
                An OCFL Object Inventory MUST include the following keys:
            </p>
            <dl>
                <dt><code>id</code></dt>
                <dd>
                    A unique identifier for the OCFL Object. This MUST be unique in the local context, and SHOULD be
                    a URI [[!RFC3986]]. There is no expectation that a URI used is resolvable. For example, URNs
                    [[RFC8141]] MAY be used.
                </dd>
                <dt><code>type</code></dt>
                <dd>
                    A type for the inventory JSON object that also serves to document the OCFL specification version
                    that the inventory complies with. This MUST be the URI of the inventory section of the
                    specification, <code>https://ocfl.io/1.0/spec/#inventory</code>.
                </dd>
                <dt><code>digestAlgorithm</code></dt>
                <dd>
                    The digest algorithm used for calculating digests within the OCFL Object. This SHOULD be
                    <code>sha512</code>, however other values are permitted. See the <a href="#digests">section on
                    Digests</a> for more information.
                </dd>
                <dt><code>head</code></dt>
                <dd>
                    A value corresponding to the version directory name of the most recent version of the object.
                </dd>
            </dl>
            <p>
                In addition to these keys, there MUST be two other blocks present, <code>manifest</code> and
                <code>versions</code>, which are discussed in the next two sections.
            </p>
        </section>

        <section id="manifest">
            <h2>Manifest</h2>
            <p>
                The value of the <code>manifest</code> key is a JSON object, with keys corresponding to the digests
                of every content file in all versions of the <a>OCFL Object</a>. The value for each key is an array
                containing the <a>existing file path</a>s of files in the OCFL Object that have content with the
                given digest. <a data-lt="existing file path">Existing file paths</a> within a manifest block MUST be
                relative to the <a>OCFL Object Root</a>.
            </p>
            <blockquote class="informative">
                <p>
                    Non-normative note: If only one file is stored in the OCFL Object for each digest, fully
                    de-duplicating the content, then there will be only one <a>existing file path</a> for each digest.
                    There may, however, be multiple logical file paths for a given digest if the content was
                    not entirely de-duplicated when constructing the OCFL Object.
                </p>
                <p>
                    An example manifest object for three existing file paths, all in version 1, is shown below:
                </p>
<pre>
  "manifest": {
    "7dcc35...c31": [ "v1/content/foo/bar.xml" ],
    "cf83e1...a3e": [ "v1/content/empty.txt" ],
    "ffccf6...62e": [ "v1/content/image.tiff" ]
  }
</pre>
            </blockquote>
        </section>

        <section id="versions">
            <h2>Versions</h2>
            <p>
                An OCFL Object Inventory MUST include a block for storing versions. This block MUST have the
                key of <code>versions</code> within the inventory, and it MUST be a JSON object. The keys of this object
                MUST correspond to the names of the <a href="#version-directories">version directories</a> used. Each
                value MUST be another JSON object that characterizes the version, as described in the
                <a href="#version"></a> section.
            </p>
            <section id="version">
                <h2>Version</h2>
                <p>
                    A JSON object to describe one <a>OCFL Version</a>, which MUST include the following keys:
                </p>
                <dl>
                    <dt>
                        <code>created</code>
                    </dt>
                    <dd>
                        The value of this key is the datetime of creation of this version. It MUST be expressed in
                        [[!ISO8601]], and SHOULD include a timezone value or UTC. It SHOULD also be granular to the
                        second level.
                    </dd>
                    <dt>
                        <code>message</code>
                    </dt>
                    <dd>
                        The value of this key is freeform text, used to record the rationale for creating this version.
                    </dd>
                    <dt>
                        <code>user</code>
                    </dt>
                    <dd>
                        The value of this key is a JSON object, containing a readable user name key, <code>name</code>
                        and an address key, <code>address</code>. The format of the address key MAY be either an
                        e-mail address or a URI reference to a personal identifier, e.g., an ORCID iD.
                    </dd>
                    <dt>
                        <code>state</code>
                    </dt>
                    <dd>
                        <p>
                            The value of this key is a JSON object, containing a list of keys and values corresponding
                            to the <a>logical state</a> of the object at that version. The keys of this JSON object
                            are digest values, each of which MUST correspond to an entry in the
                            <a href="#manifest">manifest of the inventory</a>. The value for each key is an array
                            containing <a>logical file path</a> names of files in the OCFL Object state that have
                            content with the given digest.
                        </p>
                        <blockquote class="informative">
                            <p>
                                Non-normative note: The <a>logical state</a> of the object uses content-addressing
                                to map logical file paths to their bitstreams, as expressed in the manifest
                                section of the inventory. Notably, the version state provides de-duplication of content
                                within the OCFL Object by mapping multiple logical file paths with the same content to
                                the same digest in the manifest. See [[OCFL-Implementation-Notes]].
                            </p>
                            <p>
                                An example state block is shown below:
                            </p>
<pre>
  "state": {
    "4d27c8...b53": [ "foo/bar.xml" ],
    "cf83e1...a3e": [ "empty.txt", "empty2.txt" ]
  }
</pre>
                            <p>
                                This state block describes an object with 3 files, two of which have the same content
                                (<code>empty.txt</code> and <code>empty2.txt</code>), and one of which is in a
                                sub-directory (<code>bar.xml</code>). The <a>logical state</a> shown as a tree
                                is thus:
                            </p>
<pre>
    ├── empty.txt
    ├── empty2.txt
    └── foo
        └── bar.xml
</pre>
                        </blockquote>
                    </dd>
                </dl>
            </section>
        </section>

        <section id="fixity">
            <h2>Fixity</h2>
            <p>
                An OCFL Object inventory MAY include a block for storing fixity checks. This block MUST have the
                key of <code>fixity</code> within the inventory.
            </p>
            <p>
                The <code>fixity</code> block MUST contain keys corresponding to <a href="#digest-algorithms">digest
                algorithms listed in the Digests section</a>. The value of each key MUST follow the structure of the
                <a href="#manifest"><code>manifest</code></a> block; that is, a key corresponding to the digest value,
                and an array of <a>existing file path</a>s that match that digest.
            </p>
            <blockquote class="informative">
                <p>
                    An example fixity block with <code>md5</code> and <code>sha1</code> digests is shown below.
                </p>
<pre>
  "fixity": {
    "md5": {
      "184f84e28cbe75e050e9c25ea7f2e939": [ "v1/content/foo/bar.xml" ],
      "2673a7b11a70bc7ff960ad8127b4adeb": [ "v2/content/foo/bar.xml" ],
      "c289c8ccd4bab6e385f5afdd89b5bda2": [ "v1/content/image.tiff" ],
      "d41d8cd98f00b204e9800998ecf8427e": [ "v1/content/empty.txt" ]
    },
    "sha1": {
      "66709b068a2faead97113559db78ccd44712cbf2": [ "v1/content/foo/bar.xml" ],
      "a6357c99ecc5752931e133227581e914968f3b9c": [ "v2/content/foo/bar.xml" ],
      "b9c7ccc6154974288132b63c15db8d2750716b49": [ "v1/content/image.tiff" ],
      "da39a3ee5e6b4b0d3255bfef95601890afd80709": [ "v1/content/empty.txt" ]
    }
  }
</pre>
            </blockquote>
        </section>
    </section>

    <section id="inventory-digest">
        <h2>Inventory Digest</h2>
        <p>
            Every occurrence of an inventory file MUST have an accompanying sidecar file stating its digest. This
            sidecar file must be of the form <code>inventory.json.ALGORITHM</code>, where <code>ALGORITHM</code> is
            the chosen digest algorithm for the object. An example might be <code>inventory.json.sha512</code>.
        </p>
        <p>
            The digest sidecar file MUST contain the digest of the inventory file. This MUST follow the format
            <code>DIGEST inventory.json</code>; that is, the digest of the inventory file, a single space, and the
            string <code>inventory.json</code> which is the name of the inventory file in the same directory.
        </p>
        <p>
            The digest of the inventory MUST be computed only after all changes to the inventory have been made, so this
            sidecar file SHOULD be created as the last step in the versioning process.
        </p>
    </section>

    <section id="version-inventory">
        <h2>Version Inventory and Inventory Digest</h2>
        <p>
            Every version directory SHOULD include an inventory file that is an <a href="#inventory">Inventory</a>
            of all content for versions up to and including that particular version. Every inventory file MUST have
            a corresponding <a href="#inventory-digest">Inventory Digest</a>.
        </p>
        <blockquote class="informative">
            Non-normative note: Storing an inventory for every version provides redundancy for this critical
            information in a way that is compatible with storage strategies that have immutable version directories.
        </blockquote>
    </section>

    <section id="logs-directory">
        <h2>Logs Directory</h2>
        <p>
            The base directory of the object MAY contain a logs directory, which MAY be empty. Implementers SHOULD use
            this for storing files that contain a record of actions taken on the object. Since these logs may be subject
            to local standards requirements, the format of these logs is considered out-of-scope for the OCFL Object.
            Clients operating on the object MAY log actions here that are not otherwise captured.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: The purpose of the logs directory is to provide implementers with a location for
                storing local information about actions to the OCFL Object's content that is not part of the content
                itself.
            </p>
            <p>
                As an example, implementers may have different local requirements to store audit information for their
                content. Some may wish to store a log entry indicating that an audit was conducted, and nothing was
                wrong, while others may wish to only store a log entry if an intervention was required.
            </p>
        </blockquote>

    </section>
</section>

<section id="storage-root">
    <h2>OCFL Storage Root</h2>
    <p>
      An <a>OCFL Storage Root</a> is the base directory of an OCFL storage layout.
    </p>

    <section id="root-structure">
        <h2>Root Structure</h2>
        <p>
          An OCFL Storage Root MUST contain a
          <a href="#root-conformance-declaration">Root Conformance Declaration</a> identifying it as such.
        </p>
        <p>
          An OCFL Storage Root MAY contain other files. These might include a human-readable copy of the OCFL
          specification to make the storage root self-documenting, or files used by <a href="#root-extensions">storage
          root extensions</a>.
        </p>
        <p>
          An OCFL Storage Root MAY contain a JSON file named <code>ocfl_layout.json</code> to describe the arrangement
          of directories and OCFL objects under the storage root.
          If present, this JSON document MUST include the following two keys in the root JSON object:
        </p>
        <ul>
          <li>
            <code>uri</code> - A URI identifying the precise arrangement of directories and OCFL objects under the
            storage root, i.e. how OCFL object identifiers are mapped to directory hierarchies.
            If a URL is used then it SHOULD resolve to a detailed specification of the arrangement.
          </li>
          <li>
            <code>description</code> - A human readable description of the arrangement of directories and OCFL
            objects under the storage root.
          </li>
        </ul>
        <p>
          Sub-directories within a storage root MUST NOT contain files that are not part of an OCFL Object. Empty
          directories MUST NOT appear within a storage root.
        </p>
        <p>
          Although implementations may require multiple OCFL Storage Roots&mdash;that is, several logical or
          physical volumes, or multiple "buckets" in an object store&mdash;each OCFL Storage Root MUST be independent.
        </p>
        <p>
          The following example OCFL Storage Root represents the minimal set of files and folders:
        </p>
        <pre>
[storage_root]
    ├── 0=ocfl_1.0
    ├── ocfl_1.0.txt (human-readable text of the OCFL specification; optional)
    └── ocfl_layout.json (description of storage hierarchy layout; optional)
        </pre>
    </section>

    <section id="root-conformance-declaration">
        <h2>Root Conformance Declaration</h2>
        <p>
          The OCFL version declaration MUST be formatted according to the [[!NAMASTE]] specification. It MUST be an
          empty file in the base directory of the <a>OCFL Storage Root</a> giving the OCFL version in the filename.
          The filename MUST be constructed with a leading zero-equals (<code>0=</code>) string, the string
          <code>ocfl_</code>, followed by the OCFL specification version number. For example <code>0=ocfl_1.0</code>
          for version 1.0 of this specification.
        </p>
        <p>
          Root conformance indicates that the OCFL Storage Root conforms to this section (i.e. the OCFL Storage Root
          section) of the specification.  OCFL Objects within the OCFL Storage Root also include a conformance
          declaration which MUST indicate OCFL Object conformance to the same or earlier version of the specification.
        </p>
    </section>

    <section id="root-hierarchies">
        <h2>Storage Hierarchies</h2>
        <p>
          <a>OCFL Object Root</a>s MUST be stored either as the terminal resource at the end of a directory storage
          hierarchy or as direct children of a containing <a>OCFL Storage Root</a>.
        </p>
        <p>
          A common practice is to use a unique identifier scheme to compose this storage hierarchy, typically arranged
          according to some form of the [[PairTree]] specification. Irrespective of the pattern chosen for the storage
          hierarchies, the following restrictions apply:
        </p>
        <ol>
          <li>Storage hierarchies MUST NOT include files within intermediate directories</li>
          <li>Storage hierarchies MUST be terminated by OCFL Object Roots</li>
          <li>Storage hierarchies within the same OCFL Storage Root SHOULD use just one layout pattern</li>
          <li>Storage hierarchies within the same OCFL Storage Root SHOULD consistently use either a directory
            hierarchy of OCFL Objects or top-level OCFL Objects
          </li>
        </ol>
    </section>

    <section id="root-extensions">
        <h2>Extensions</h2>
        <p>
            The behavior of the storage root may be extended to support features from other specifications.
            An OCFL validator MUST ignore any files in the storage root it does not understand. Additional 
            files MUST NOT appear in other directories under the storage root.
        </p>
        <blockquote class="informative">
            <p>
                Non-normative note: Storage extensions can be used to support additional features, such as providing
                the storage hierarchy disposition when pairtree is in use, or additional human-readable text about the
                nature of the storage root.
            </p>
        </blockquote>
    </section>

</section>

<section id="examples" class="informative">
    <h2>Examples</h2>

    <section id="example-minimal-object">
        <h2>Minimal OCFL Object</h2>
        <p>
            The following example OCFL Object has content that is a single file
            (<code>file.txt</code>), and just one version (<code>v1</code>):
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    └── v1
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
            └── file.txt
</pre>
        <p>
            The inventory for this OCFL Object, the same both at the top-level and
            in the <code>v1</code> directory, might be:
        </p>
<pre>
{
  "digestAlgorithm": "sha512",
  "head": "v1",
  "id": "http://example.org/minimal",
  "manifest": {
    "7545b8...f67": [ "v1/content/file.txt" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2018-10-02T12:00:00Z",
      "message": "One file",
      "state": {
        "7545b8...f67": [ "file.txt" ]
      },
      "user": {
        "address": "alice@example.org",
        "name": "Alice"
      }
    }
  }
}
</pre>
    </section>

    <section id="example-versioned-object">
        <h2>Versioned OCFL Object</h2>
        <p>
            The following example OCFL Object has three versions:
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    ├── v1        
    │   ├── inventory.json
    │   ├── inventory.json.sha512
    │   └── content
    │       ├── empty.txt
    │       ├── foo
    │       │   └── bar.xml
    │       └── image.tiff
    ├── v2    
    │   ├── inventory.json
    │   ├── inventory.json.sha512
    │   └── content
    │       └── foo
    │           └── bar.xml
    └── v3
        ├── inventory.json
        ├── inventory.json.sha512
        └── content


</pre>
        <p>
            In <code>v1</code> there are three files, <code>empty.txt</code>, <code>foo/bar.xml</code>,
            and <code>image.tiff</code>. In <code>v2</code> the content of <code>foo/bar.xml</code> is changed,
            <code>empty2.txt</code> is added with the same content as <code>empty.txt</code>, and
            <code>image.tiff</code> is removed. In <code>v3</code> the file <code>empty.txt</code> is
            removed, and <code>image.tiff</code> is reinstated. As a result of forward-delta versioning, the
            object tree above shows only new content added in each version. The inventory shown below details
            the other changes, includes additional fixity information using <code>md5</code> and
            <code>sha1</code> digest algorithms, and minimal metadata for each version.
        </p>
<pre>
{
  "digestAlgorithm": "sha512",
  "fixity": {
    "md5": {
      "184f84e28cbe75e050e9c25ea7f2e939": [ "v1/content/foo/bar.xml" ],
      "2673a7b11a70bc7ff960ad8127b4adeb": [ "v2/content/foo/bar.xml" ],
      "c289c8ccd4bab6e385f5afdd89b5bda2": [ "v1/content/image.tiff" ],
      "d41d8cd98f00b204e9800998ecf8427e": [ "v1/content/empty.txt" ]
    },
    "sha1": {
      "66709b068a2faead97113559db78ccd44712cbf2": [ "v1/content/foo/bar.xml" ],
      "a6357c99ecc5752931e133227581e914968f3b9c": [ "v2/content/foo/bar.xml" ],
      "b9c7ccc6154974288132b63c15db8d2750716b49": [ "v1/content/image.tiff" ],
      "da39a3ee5e6b4b0d3255bfef95601890afd80709": [ "v1/content/empty.txt" ]
    }
  },
  "head": "v3",
  "id": "ark:/12345/bcd987",
  "manifest": {
    "4d27c8...b53": [ "v2/content/foo/bar.xml" ],
    "7dcc35...c31": [ "v1/content/foo/bar.xml" ],
    "cf83e1...a3e": [ "v1/content/empty.txt" ],
    "ffccf6...62e": [ "v1/content/image.tiff" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2018-01-01T01:01:01Z",
      "message": "Initial import",
      "state": {
        "7dcc35...c31": [ "foo/bar.xml" ],
        "cf83e1...a3e": [ "empty.txt" ],
        "ffccf6...62e": [ "image.tiff" ]
      },
      "user": {
        "address": "alice@example.com",
        "name": "Alice"
      }
    },
    "v2": {
      "created": "2018-02-02T02:02:02Z",
      "message": "Fix bar.xml, remove image.tiff, add empty2.txt",
      "state": {
        "4d27c8...b53": [ "foo/bar.xml" ],
        "cf83e1...a3e": [ "empty.txt", "empty2.txt" ]
      },
      "user": {
        "address": "bob@example.com",
        "name": "Bob"
      }
    },
    "v3": {
      "created": "2018-03-03T03:03:03Z",
      "message": "Reinstate image.tiff, delete empty.txt",
      "state": {
        "4d27c8...b53": [ "foo/bar.xml" ],
        "cf83e1...a3e": [ "empty2.txt" ],
        "ffccf6...62e": [ "image.tiff" ]
      },
      "user": {
        "address": "cecilia@example.com",
        "name": "Cecilia"
      }
    }
  }
}
</pre>
    </section>

    <section id="example-bagit-in-ocfl">
        <h2>BagIt in an OCFL Object</h2>
        <p>
            [[BagIt]] is a common file packaging specification, but unlike OCFL it does not provide a mechanism for
            content versioning. Using OCFL it is possible to store a BagIt structure with content versioning, such
            that when the object state is resolved, it creates a valid BagIt 'bag'. This example will illustrate how
            this can be accomplished, using the <a href="https://tools.ietf.org/html/draft-kunze-bagit-17#section-4.1">
            example of a basic bag</a> given in the BagIt specification.
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    └── v1
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
            └── myfirstbag
                ├── bagit.txt
                ├── data
                │   └── 27613-h
                │       └── images
                │           ├── q172.png
                │           └── q172.txt
                └── manifest-md5.txt
</pre>

        <p>
            If, for example, a new directory were added in a subsequent version, the OCFL Object would look like this:
        </p>
<pre>
[object root]
    ├── 0=ocfl_object_1.0
    ├── inventory.json
    ├── inventory.json.sha512
    ├── v1
    │   ├── inventory.json
    │   ├── inventory.json.sha512
    │   └── content
    │       └── myfirstbag
    │           ├── bagit.txt
    │           ├── data
    │           │   └── 27613-h
    │           │       └── images
    │           │           ├── q172.png
    │           │           └── q172.txt
    │           └── manifest-md5.txt
    └── v2
        ├── inventory.json
        ├── inventory.json.sha512
        └── content
            └── myfirstbag
                ├── data
                │   └── 27614-h
                │       └── images
                │           ├── q173.png
                │           └── q173.txt
                └── manifest-md5.txt
</pre>
        <p>
            The state of the object at version 2 would be the following BagIt object:
        </p>
<pre>
myfirstbag
    ├── bagit.txt
    ├── data
    │   ├── 27613-h
    │   │   └── images
    │   │       ├── q172.png
    │   │       └── q172.txt
    │   └── 27614-h
    │       └── images
    │           ├── q173.png
    │           └── q173.txt
    └── manifest-md5.txt
</pre>
        <p>
            The OCFL Inventory for this object would be as follows:
        </p>
<pre>
{
  "digestAlgorithm": "sha512",
  "head": "v1",
  "id": "urn:uri:example.com/myfirstbag",
  "manifest": {
    "cf83e1...a3e": [ "v1/content/myfirstbag/bagit.txt" ],
    "f15428...83f": [ "v1/content/myfirstbag/manifest-md5.txt" ],
    "85f2b0...007": [ "v1/content/myfirstbag/data/27613-h/images/q172.png" ],
    "d66d80...8bd": [ "v1/content/myfirstbag/data/27613-h/images/q172.txt" ],
    "2b0ff8...620": [ "v2/content/myfirstbag/manifest-md5.txt" ],
    "921d36...877": [ "v2/content/myfirstbag/data/27614-h/images/q173.png" ],
    "b8bdf1...927": [ "v2/content/myfirstbag/data/27614-h/images/q173.txt" ]
  },
  "type": "https://ocfl.io/1.0/spec/#inventory",
  "versions": {
    "v1": {
      "created": "2018-10-09T11:20:29.209164Z",
      "message": "Initial Ingest",
      "state": {
        "cf83e1...a3e": [ "myfirstbag/bagit.txt" ],
        "85f2b0...007": [ "myfirstbag/data/27613-h/images/q172.png" ],
        "d66d80...8bd": [ "myfirstbag/data/27613-h/images/q172.txt" ],
        "f15428...83f": [ "myfirstbag/manifest-md5.txt" ]
      },
      "user": {
        "address": "someone@example.org",
        "name": "Some One"
      }
    },
    "v2": {
      "created": "2018-10-31T11:20:29.209164Z",
      "message": "Added new images",
      "state": {
        "cf83e1...a3e": [ "myfirstbag/bagit.txt" ],
        "85f2b0...007": [ "myfirstbag/data/27613-h/images/q172.png" ],
        "d66d80...8bd": [ "myfirstbag/data/27613-h/images/q172.txt" ],
        "2b0ff8...620": [ "myfirstbag/manifest-md5.txt" ],
        "921d36...877": [ "myfirstbag/data/27614-h/images/q173.png" ],
        "b8bdf1...927": [ "myfirstbag/data/27614-h/images/q173.txt" ]
      },
      "user": {
        "address": "somebody-else@example.org",
        "name": "Somebody Else"
      }
    }
  ]
}
</pre>
    </section>

    <section id="example-moab-in-ocfl">
        <h2>Moab in an OCFL Object</h2>
        <p>
            [[Moab]] is an archive information package format developed and used by Stanford University.
            Many of the ideas in Moab have been refined by OCFL, and OCFL is designed to
            give institutions currently using Moab an easy path to adoption.
        </p>
        <p>
            Converting content preserved in a Moab object in a way that does not compromise existing Moab
            access patterns whilst allowing for the eventual use of OCFL-native workflows requires a Moab to
            OCFL conversion tool. This tool uses the Moab-versioning gem to extract deltas and digests
            of the Moab data directory for each Moab version and translate those into version state blocks
            in an OCFL inventory file, which would be placed in the root directory of the Moab object.
            All extant files in the Moab version directories are tracked in the manifest block. The contents
            of the Moab manifests directory are not tracked in the version state blocks; they are effectively
            deleted from the OCFL object without compromising legacy access patterns.
        </p>
        <p>
            During the transitionary period the OCFL inventory file exists only in the root of the Moab object.
            Once OCFL-native object creation workflows have been completed, future versions of that object will
            be fully OCFL compliant - new versions will no longer have a manifests directory and will contain an
            OCFL inventory file. At this stage OCFL tools will be able to access all versions of the content
            originally preserved by Moab.
        </p>
        <p>
            Consider the following sample Moab object:
        </p>
<pre>
[object root]
    └── bj102hs9687
        ├── v0001
        │   └──content
        │       ├── data
        │       │   ├── content
        │       │   │   ├── eric-smith-dissertation-augmented.pdf
        │       │   │   └── eric-smith-dissertation.pdf
        │       │   └── metadata
        │       │       ├── contentMetadata.xml
        │       │       ├── descMetadata.xml
        │       │       ├── identityMetadata.xml
        │       │       ├── provenanceMetadata.xml
        │       │       ├── relationshipMetadata.xml
        │       │       ├── rightsMetadata.xml
        │       │       ├── technicalMetadata.xml
        │       │       └── versionMetadata.xml
        │       └── manifests
        │           ├── fileInventoryDifference.xml
        │           ├── manifestInventory.xml
        │           ├── signatureCatalog.xml
        │           ├── versionAdditions.xml
        │           └── versionInventory.xml
        ├── v0002
        │   └──content
        │       ├── data
        │       │   └── metadata
        │       │       ├── contentMetadata.xml
        │       │       ├── embargoMetadata.xml
        │       │       ├── events.xml
        │       │       ├── identityMetadata.xml
        │       │       ├── provenanceMetadata.xml
        │       │       ├── relationshipMetadata.xml
        │       │       ├── rightsMetadata.xml
        │       │       ├── versionMetadata.xml
        │       │       └── workflows.xml
        │       └── manifests
        │           ├── fileInventoryDifference.xml
        │           ├── manifestInventory.xml
        │           ├── signatureCatalog.xml
        │           ├── versionAdditions.xml
        │           └── versionInventory.xml
        └── v0003
            └──content
                ├── data
                │   └── metadata
                │       ├── contentMetadata.xml
                │       ├── descMetadata.xml
                │       ├── embargoMetadata.xml
                │       ├── events.xml
                │       ├── identityMetadata.xml
                │       ├── provenanceMetadata.xml
                │       ├── rightsMetadata.xml
                │       ├── technicalMetadata.xml
                │       ├── versionMetadata.xml
                │       └── workflows.xml
                └── manifests
                    ├── fileInventoryDifference.xml
                    ├── manifestInventory.xml
                    ├── signatureCatalog.xml
                    ├── versionAdditions.xml
                    └── versionInventory.xml
</pre>
        <p>
            An OCFL inventory that tracks the /data directory would include a manifest comprised as follows:
        </p>
<pre>
"manifest": {
    "197320...2e1": [ "v0001/content/manifests/manifestInventory.xml" ],
    "a64b62...5c3": [ "v0001/content/manifests/versionAdditions.xml" ],
    "794d5e...38b": [ "v0001/content/manifests/signatureCatalog.xml" ],
    "a4d20f...b48": [ "v0001/content/manifests/fileInventoryDifference.xml" ],
    "363785...bfb": [ "v0001/content/manifests/versionInventory.xml" ],
    "98114a...588": [ "v0001/content/data/content/eric-smith-dissertation-augmented.pdf" ],
    "7f3d87...15b": [ "v0001/content/data/content/eric-smith-dissertation.pdf" ],
    "6d19f0...064": [ "v0001/content/data/metadata/technicalMetadata.xml" ],
    "6e4be4...375": [ "v0001/content/data/metadata/provenanceMetadata.xml" ],
    "d8a319...d0f": [ "v0001/content/data/metadata/descMetadata.xml" ],
    "de823a...acc": [ "v0001/content/data/metadata/rightsMetadata.xml" ],
    "080617...40c": [ "v0001/content/data/metadata/identityMetadata.xml" ],
    "e15267...58d": [ "v0001/content/data/metadata/versionMetadata.xml" ],
    "0d9e0b...9a2": [ "v0001/content/data/metadata/contentMetadata.xml" ],
    "dd9289...31d": [ "v0001/content/data/metadata/relationshipMetadata.xml" ],
    "f90947...11b": [ "v0002/content/manifests/manifestInventory.xml" ],
    "bb3011...a58": [ "v0002/content/manifests/versionAdditions.xml" ],
    "0dc4fc...f9f": [ "v0002/content/manifests/signatureCatalog.xml" ],
    "2f1cf8...ea1": [ "v0002/content/manifests/fileInventoryDifference.xml" ],
    "45b457...db5": [ "v0002/content/manifests/versionInventory.xml" ],
    "7519c5...63f": [ "v0002/content/data/metadata/provenanceMetadata.xml" ],
    "abda4c...622": [ "v0002/content/data/metadata/workflows.xml" ],
    "76549e...b2b": [ "v0002/content/data/metadata/rightsMetadata.xml" ],
    "bdc4d6...3b6": [ "v0002/content/data/metadata/events.xml" ],
    "7b331c...f9b": [ "v0002/content/data/metadata/identityMetadata.xml" ],
    "80ceac...b9c": [ "v0002/content/data/metadata/versionMetadata.xml" ],
    "4853a2...fbe": [ "v0002/content/data/metadata/contentMetadata.xml" ],
    "1d5090...f5f": [ "v0002/content/data/metadata/relationshipMetadata.xml" ],
    "f209bf...ceb": [ "v0002/content/data/metadata/embargoMetadata.xml" ],
    "04461b...5c6": [ "v0003/content/manifests/manifestInventory.xml" ],
    "190103...20f": [ "v0003/content/manifests/versionAdditions.xml" ],
    "24a84a...82d": [ "v0003/content/manifests/signatureCatalog.xml" ],
    "5f4d52...7ef": [ "v0003/content/manifests/fileInventoryDifference.xml" ],
    "2d7f8d...d67": [ "v0003/content/manifests/versionInventory.xml" ],
    "dd9125...d4b": [ "v0003/content/data/metadata/technicalMetadata.xml" ],
    "d9e177...477": [ "v0003/content/data/metadata/provenanceMetadata.xml" ],
    "4f5908...4f5": [ "v0003/content/data/metadata/workflows.xml" ],
    "e64db0...500": [ "v0003/content/data/metadata/descMetadata.xml" ],
    "05fa51...818": [ "v0003/content/data/metadata/rightsMetadata.xml" ],
    "d70dd8...5ad": [ "v0003/content/data/metadata/events.xml" ],
    "509a2d...dc6": [ "v0003/content/data/metadata/identityMetadata.xml" ],
    "548066...893": [ "v0003/content/data/metadata/versionMetadata.xml" ],
    "93884e...aae": [ "v0003/content/data/metadata/contentMetadata.xml" ],
    "4c5ab4...b02": [ "v0003/content/data/metadata/embargoMetadata.xml" ]
}
</pre>
    <p>
        The version 1 state block would look like this. Note the absence of the manifests/ directory.
    </p>
<pre>
"state": {
    "98114a...588": [ "data/content/eric-smith-dissertation-augmented.pdf" ],
    "7f3d87...15b": [ "data/content/eric-smith-dissertation.pdf" ],
    "6d19f0...064": [ "data/metadata/technicalMetadata.xml" ],
    "6e4be4...375": [ "data/metadata/provenanceMetadata.xml" ],
    "d8a319...d0f": [ "data/metadata/descMetadata.xml" ],
    "de823a...acc": [ "data/metadata/rightsMetadata.xml" ],
    "080617...40c": [ "data/metadata/identityMetadata.xml" ],
    "e15267...58d": [ "data/metadata/versionMetadata.xml" ],
    "0d9e0b...9a2": [ "data/metadata/contentMetadata.xml" ],
    "dd9289...31d": [ "data/metadata/relationshipMetadata.xml" ]
}
</pre>
    <p>
        The version 2 state block would contain:
    </p>
<pre>
"state": {
    "98114a...588": [ "data/content/eric-smith-dissertation-augmented.pdf" ],
    "7f3d87...15b": [ "data/content/eric-smith-dissertation.pdf" ],
    "6d19f0...064": [ "data/metadata/technicalMetadata.xml" ],
    "7519c5...63f": [ "data/metadata/provenanceMetadata.xml" ],
    "d8a319...d0f": [ "data/metadata/descMetadata.xml" ],
    "76549e...b2b": [ "data/metadata/rightsMetadata.xml" ],
    "7b331c...f9b": [ "data/metadata/identityMetadata.xml" ],
    "80ceac...b9c": [ "data/metadata/versionMetadata.xml" ],
    "4853a2...fbe": [ "data/metadata/contentMetadata.xml" ],
    "1d5090...f5f": [ "data/metadata/relationshipMetadata.xml" ],
    "abda4c...622": [ "data/metadata/workflows.xml" ],
    "bdc4d6...3b6": [ "data/metadata/events.xml" ],
    "f209bf...ceb": [ "data/metadata/embargoMetadata.xml" ]
}
</pre>
    <p>
        The version 3 state block would be:
    </p>
<pre>
"state": {
    "98114a...588": [ "data/content/eric-smith-dissertation-augmented.pdf" ],
    "7f3d87...15b": [ "data/content/eric-smith-dissertation.pdf" ],
    "dd9125...d4b": [ "data/metadata/technicalMetadata.xml" ],
    "d9e177...477": [ "data/metadata/provenanceMetadata.xml" ],
    "e64db0...500": [ "data/metadata/descMetadata.xml" ],
    "05fa51...818": [ "data/metadata/rightsMetadata.xml" ],
    "509a2d...dc6": [ "data/metadata/identityMetadata.xml" ],
    "548066...893": [ "data/metadata/versionMetadata.xml" ],
    "93884e...aae": [ "data/metadata/contentMetadata.xml" ],
    "1d5090...f5f": [ "data/metadata/relationshipMetadata.xml" ],
    "4f5908...4f5": [ "data/metadata/workflows.xml" ],
    "d70dd8...5ad": [ "data/metadata/events.xml" ],
    "4c5ab4...b02": [ "data/metadata/embargoMetadata.xml" ]
}
</pre>

    </section>
</section>

</body>
</html>
